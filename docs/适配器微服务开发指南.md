# é€‚é…å™¨å¾®æœåŠ¡å¼€å‘æŒ‡å—

## ğŸ¯ ä¸€ã€é€‚é…å™¨æ¨¡å¼æ¶æ„

### 1.1 æ•´ä½“æ¶æ„

```mermaid
graph LR
    subgraph å¼€æºæœåŠ¡å±‚
        ES[Elasticsearch<br/>æœç´¢å¼•æ“]
        MINIO[MinIO<br/>å¯¹è±¡å­˜å‚¨]
        MQTT[EMQX<br/>æ¶ˆæ¯é˜Ÿåˆ—]
        OLLAMA[Ollama<br/>æœ¬åœ°å¤§æ¨¡å‹]
        INFLUX[InfluxDB<br/>æ—¶åºæ•°æ®åº“]
        GRAFANA[Grafana<br/>ç›‘æ§é¢æ¿]
    end
    
    subgraph é€‚é…å™¨å±‚[Javaé€‚é…å™¨å¾®æœåŠ¡]
        ES_ADAPTER[ESé€‚é…å™¨æœåŠ¡<br/>æœç´¢ä¸šåŠ¡å°è£…]
        STORAGE_ADAPTER[å­˜å‚¨é€‚é…å™¨æœåŠ¡<br/>æ–‡ä»¶ä¸šåŠ¡å°è£…]
        IOT_ADAPTER[IoTé€‚é…å™¨æœåŠ¡<br/>è®¾å¤‡æ¶ˆæ¯å°è£…]
        AI_ADAPTER[AIé€‚é…å™¨æœåŠ¡<br/>æ¨¡å‹è°ƒç”¨å°è£…]
        METRICS_ADAPTER[æŒ‡æ ‡é€‚é…å™¨æœåŠ¡<br/>æ•°æ®åˆ†æå°è£…]
    end
    
    subgraph å¹³å°å±‚
        GATEWAY[API Gateway<br/>ç»Ÿä¸€å…¥å£]
        REGISTRY[æœåŠ¡æ³¨å†Œä¸­å¿ƒ]
    end
    
    ES --> ES_ADAPTER
    MINIO --> STORAGE_ADAPTER
    MQTT --> IOT_ADAPTER
    OLLAMA --> AI_ADAPTER
    INFLUX --> METRICS_ADAPTER
    GRAFANA --> METRICS_ADAPTER
    
    ES_ADAPTER --> REGISTRY
    STORAGE_ADAPTER --> REGISTRY
    IOT_ADAPTER --> REGISTRY
    AI_ADAPTER --> REGISTRY
    METRICS_ADAPTER --> REGISTRY
    
    REGISTRY --> GATEWAY
```

### 1.2 é€‚é…å™¨æœåŠ¡èŒè´£

- **åè®®è½¬æ¢**ï¼šå°†å¼€æºæœåŠ¡çš„åŸç”Ÿåè®®è½¬æ¢ä¸ºç»Ÿä¸€çš„REST API
- **ä¸šåŠ¡å°è£…**ï¼šæ·»åŠ ä¸šåŠ¡é€»è¾‘ã€æƒé™æ§åˆ¶ã€æ•°æ®éªŒè¯
- **è¿æ¥ç®¡ç†**ï¼šç®¡ç†ä¸å¼€æºæœåŠ¡çš„è¿æ¥æ± ã€é‡è¯•æœºåˆ¶
- **æ•°æ®è½¬æ¢**ï¼šç»Ÿä¸€æ•°æ®æ ¼å¼ï¼Œå±è”½åº•å±‚å·®å¼‚
- **ç›‘æ§é›†æˆ**ï¼šæä¾›å¥åº·æ£€æŸ¥ã€æ€§èƒ½æŒ‡æ ‡

## ğŸ“¦ äºŒã€é€‚é…å™¨æœåŠ¡æ¨¡æ¿

### 2.1 æ ‡å‡†é¡¹ç›®ç»“æ„

```
adapter-service-template/
â”œâ”€â”€ adapter-core/                    # æ ¸å¿ƒæ¨¡å—
â”‚   â”œâ”€â”€ src/main/java/
â”‚   â”‚   â”œâ”€â”€ config/                 # é…ç½®ç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ ClientConfig.java   # å®¢æˆ·ç«¯é…ç½®
â”‚   â”‚   â”‚   â”œâ”€â”€ PoolConfig.java     # è¿æ¥æ± é…ç½®
â”‚   â”‚   â”‚   â””â”€â”€ RetryConfig.java    # é‡è¯•é…ç½®
â”‚   â”‚   â”œâ”€â”€ client/                 # åŸç”Ÿå®¢æˆ·ç«¯å°è£…
â”‚   â”‚   â”‚   â”œâ”€â”€ NativeClient.java   # åº•å±‚å®¢æˆ·ç«¯
â”‚   â”‚   â”‚   â””â”€â”€ ClientFactory.java  # å®¢æˆ·ç«¯å·¥å‚
â”‚   â”‚   â”œâ”€â”€ converter/              # æ•°æ®è½¬æ¢å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ RequestConverter.java
â”‚   â”‚   â”‚   â””â”€â”€ ResponseConverter.java
â”‚   â”‚   â”œâ”€â”€ service/                # ä¸šåŠ¡æœåŠ¡å±‚
â”‚   â”‚   â”‚   â”œâ”€â”€ AdapterService.java # é€‚é…å™¨æ ¸å¿ƒæœåŠ¡
â”‚   â”‚   â”‚   â””â”€â”€ BusinessService.java # ä¸šåŠ¡é€»è¾‘å°è£…
â”‚   â”‚   â”œâ”€â”€ controller/             # RESTæ¥å£
â”‚   â”‚   â”‚   â””â”€â”€ AdapterController.java
â”‚   â”‚   â””â”€â”€ health/                 # å¥åº·æ£€æŸ¥
â”‚   â”‚       â””â”€â”€ ServiceHealthIndicator.java
â”‚   â””â”€â”€ src/main/resources/
â”‚       â”œâ”€â”€ application.yml         # åº”ç”¨é…ç½®
â”‚       â””â”€â”€ bootstrap.yml           # å¯åŠ¨é…ç½®
â”œâ”€â”€ adapter-api/                    # APIå®šä¹‰æ¨¡å—
â”‚   â””â”€â”€ src/main/java/
â”‚       â”œâ”€â”€ dto/                    # æ•°æ®ä¼ è¾“å¯¹è±¡
â”‚       â”œâ”€â”€ api/                    # Feignæ¥å£å®šä¹‰
â”‚       â””â”€â”€ constant/               # å¸¸é‡å®šä¹‰
â””â”€â”€ adapter-client/                 # å®¢æˆ·ç«¯SDKæ¨¡å—
    â””â”€â”€ src/main/java/
        â””â”€â”€ client/                 # Feignå®¢æˆ·ç«¯å®ç°
```

### 2.2 åŸºç¡€é€‚é…å™¨ç±»

```java
// é€‚é…å™¨æœåŠ¡åŸºç±»
@Slf4j
public abstract class BaseAdapterService<T, R> {
    
    // è·å–åŸç”Ÿå®¢æˆ·ç«¯
    protected abstract T getNativeClient();
    
    // æ•°æ®è½¬æ¢
    protected abstract R convertResponse(Object nativeResponse);
    
    // æ‰§è¡Œé€‚é…å™¨è°ƒç”¨
    protected R execute(Function<T, Object> operation) {
        // è·å–å®¢æˆ·ç«¯
        T client = getNativeClient();
        
        // è®°å½•è°ƒç”¨å¼€å§‹
        long startTime = System.currentTimeMillis();
        String traceId = MDC.get("traceId");
        
        try {
            // æ‰§è¡ŒåŸç”Ÿè°ƒç”¨
            Object nativeResult = operation.apply(client);
            
            // è½¬æ¢å“åº”
            R result = convertResponse(nativeResult);
            
            // è®°å½•æˆåŠŸ
            recordSuccess(System.currentTimeMillis() - startTime);
            
            return result;
            
        } catch (Exception e) {
            // è®°å½•å¤±è´¥
            recordFailure(e);
            
            // å¼‚å¸¸è½¬æ¢
            throw translateException(e);
        }
    }
    
    // é‡è¯•æœºåˆ¶
    protected R executeWithRetry(Function<T, Object> operation, int maxRetries) {
        int attempts = 0;
        Exception lastException = null;
        
        while (attempts < maxRetries) {
            try {
                return execute(operation);
            } catch (Exception e) {
                lastException = e;
                attempts++;
                
                if (shouldRetry(e) && attempts < maxRetries) {
                    log.warn("Retry attempt {} after error: {}", attempts, e.getMessage());
                    sleep(calculateBackoff(attempts));
                } else {
                    break;
                }
            }
        }
        
        throw new AdapterException("Failed after " + attempts + " attempts", lastException);
    }
    
    // åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
    protected boolean shouldRetry(Exception e) {
        return e instanceof IOException || 
               e instanceof TimeoutException ||
               e instanceof ConnectException;
    }
    
    // è®¡ç®—é€€é¿æ—¶é—´
    protected long calculateBackoff(int attempt) {
        return Math.min(1000 * (long) Math.pow(2, attempt), 30000);
    }
    
    // å¼‚å¸¸è½¬æ¢
    protected RuntimeException translateException(Exception e) {
        if (e instanceof TimeoutException) {
            return new ServiceTimeoutException("Service timeout", e);
        } else if (e instanceof ConnectException) {
            return new ServiceUnavailableException("Service unavailable", e);
        } else {
            return new AdapterException("Adapter error", e);
        }
    }
    
    // æ€§èƒ½ç›‘æ§
    private void recordSuccess(long duration) {
        Metrics.counter("adapter.calls", "status", "success").increment();
        Metrics.timer("adapter.duration").record(duration, TimeUnit.MILLISECONDS);
    }
    
    private void recordFailure(Exception e) {
        Metrics.counter("adapter.calls", "status", "failure", 
                       "error", e.getClass().getSimpleName()).increment();
    }
}
```

## ğŸ”Œ ä¸‰ã€å…·ä½“é€‚é…å™¨å®ç°ç¤ºä¾‹

### 3.1 Elasticsearché€‚é…å™¨æœåŠ¡

```java
// ESé€‚é…å™¨æœåŠ¡å®ç°
@Service
@Slf4j
public class ElasticsearchAdapterService extends BaseAdapterService<RestHighLevelClient, SearchResult> {
    
    @Autowired
    private RestHighLevelClient esClient;
    
    @Autowired
    private QueryBuilder queryBuilder;
    
    @Override
    protected RestHighLevelClient getNativeClient() {
        return esClient;
    }
    
    @Override
    protected SearchResult convertResponse(Object nativeResponse) {
        SearchResponse response = (SearchResponse) nativeResponse;
        
        return SearchResult.builder()
            .total(response.getHits().getTotalHits().value)
            .took(response.getTook().millis())
            .items(Arrays.stream(response.getHits().getHits())
                .map(this::convertHit)
                .collect(Collectors.toList()))
            .aggregations(convertAggregations(response.getAggregations()))
            .build();
    }
    
    // å…¨æ–‡æœç´¢
    public SearchResult search(SearchRequest request) {
        return executeWithRetry(client -> {
            // æ„å»ºESæŸ¥è¯¢
            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
            
            // æ·»åŠ æŸ¥è¯¢æ¡ä»¶
            BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
            
            // å…³é”®è¯æœç´¢
            if (StringUtils.isNotEmpty(request.getKeyword())) {
                boolQuery.must(QueryBuilders.multiMatchQuery(request.getKeyword())
                    .field("title", 2.0f)  // æ ‡é¢˜æƒé‡æ›´é«˜
                    .field("content")
                    .field("tags"));
            }
            
            // è¿‡æ»¤æ¡ä»¶
            if (request.getFilters() != null) {
                request.getFilters().forEach((field, value) -> {
                    boolQuery.filter(QueryBuilders.termQuery(field, value));
                });
            }
            
            sourceBuilder.query(boolQuery);
            
            // åˆ†é¡µ
            sourceBuilder.from(request.getOffset());
            sourceBuilder.size(request.getLimit());
            
            // æ’åº
            if (request.getSortField() != null) {
                sourceBuilder.sort(request.getSortField(), 
                    request.isAscending() ? SortOrder.ASC : SortOrder.DESC);
            }
            
            // é«˜äº®
            if (request.isHighlight()) {
                HighlightBuilder highlightBuilder = new HighlightBuilder();
                highlightBuilder.field("title");
                highlightBuilder.field("content");
                sourceBuilder.highlighter(highlightBuilder);
            }
            
            // æ‰§è¡Œæœç´¢
            org.elasticsearch.action.search.SearchRequest esRequest = 
                new org.elasticsearch.action.search.SearchRequest(request.getIndex());
            esRequest.source(sourceBuilder);
            
            return client.search(esRequest, RequestOptions.DEFAULT);
        }, 3);
    }
    
    // èšåˆåˆ†æ
    public AggregationResult aggregate(AggregationRequest request) {
        return executeWithRetry(client -> {
            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
            
            // æ„å»ºèšåˆ
            if ("terms".equals(request.getType())) {
                sourceBuilder.aggregation(
                    AggregationBuilders.terms(request.getName())
                        .field(request.getField())
                        .size(request.getSize())
                );
            } else if ("date_histogram".equals(request.getType())) {
                sourceBuilder.aggregation(
                    AggregationBuilders.dateHistogram(request.getName())
                        .field(request.getField())
                        .calendarInterval(DateHistogramInterval.DAY)
                );
            }
            
            org.elasticsearch.action.search.SearchRequest esRequest = 
                new org.elasticsearch.action.search.SearchRequest(request.getIndex());
            esRequest.source(sourceBuilder);
            
            SearchResponse response = client.search(esRequest, RequestOptions.DEFAULT);
            
            return convertAggregationResult(response.getAggregations());
        }, 3);
    }
    
    // æ‰¹é‡ç´¢å¼•
    @Async
    public CompletableFuture<BulkResult> bulkIndex(List<Document> documents) {
        return CompletableFuture.supplyAsync(() -> {
            BulkRequest bulkRequest = new BulkRequest();
            
            documents.forEach(doc -> {
                IndexRequest indexRequest = new IndexRequest(doc.getIndex())
                    .id(doc.getId())
                    .source(doc.getSource(), XContentType.JSON);
                bulkRequest.add(indexRequest);
            });
            
            try {
                BulkResponse response = esClient.bulk(bulkRequest, RequestOptions.DEFAULT);
                
                return BulkResult.builder()
                    .success(!response.hasFailures())
                    .totalItems(documents.size())
                    .failedItems(response.hasFailures() ? 
                        Arrays.stream(response.getItems())
                            .filter(BulkItemResponse::isFailed)
                            .count() : 0)
                    .build();
                    
            } catch (IOException e) {
                throw new AdapterException("Bulk index failed", e);
            }
        });
    }
}

// ESé€‚é…å™¨æ§åˆ¶å™¨
@RestController
@RequestMapping("/api/search")
@Api(tags = "æœç´¢æœåŠ¡")
public class ElasticsearchAdapterController {
    
    @Autowired
    private ElasticsearchAdapterService adapterService;
    
    @PostMapping("/query")
    @ApiOperation("å…¨æ–‡æœç´¢")
    public Result<SearchResult> search(@RequestBody @Valid SearchRequest request) {
        // æ·»åŠ ç”¨æˆ·æƒé™è¿‡æ»¤
        String userId = UserContextHolder.getUserId();
        request.addFilter("userId", userId);
        
        SearchResult result = adapterService.search(request);
        return Result.success(result);
    }
    
    @PostMapping("/aggregate")
    @ApiOperation("èšåˆåˆ†æ")
    public Result<AggregationResult> aggregate(@RequestBody @Valid AggregationRequest request) {
        AggregationResult result = adapterService.aggregate(request);
        return Result.success(result);
    }
    
    @PostMapping("/bulk")
    @ApiOperation("æ‰¹é‡ç´¢å¼•")
    public Result<String> bulkIndex(@RequestBody List<Document> documents) {
        adapterService.bulkIndex(documents);
        return Result.success("Bulk indexing started");
    }
}
```

### 3.2 MinIOå­˜å‚¨é€‚é…å™¨æœåŠ¡

```java
// MinIOé€‚é…å™¨æœåŠ¡
@Service
@Slf4j
public class MinioAdapterService extends BaseAdapterService<MinioClient, StorageResult> {
    
    @Value("${minio.bucket:haven-storage}")
    private String defaultBucket;
    
    @Autowired
    private MinioClient minioClient;
    
    @Autowired
    private FileMetadataService metadataService;
    
    // æ–‡ä»¶ä¸Šä¼ ï¼ˆå¸¦ä¸šåŠ¡é€»è¾‘ï¼‰
    public StorageResult uploadFile(MultipartFile file, UploadOptions options) {
        return executeWithRetry(client -> {
            try {
                // ç”Ÿæˆæ–‡ä»¶ID
                String fileId = generateFileId(file, options);
                
                // æ„å»ºå­˜å‚¨è·¯å¾„
                String objectName = buildObjectPath(fileId, options);
                
                // æ–‡ä»¶é¢„å¤„ç†
                InputStream processedStream = preprocessFile(file, options);
                
                // ä¸Šä¼ åˆ°MinIO
                client.putObject(
                    PutObjectArgs.builder()
                        .bucket(options.getBucket() != null ? options.getBucket() : defaultBucket)
                        .object(objectName)
                        .stream(processedStream, file.getSize(), -1)
                        .contentType(file.getContentType())
                        .userMetadata(buildMetadata(file, options))
                        .build()
                );
                
                // ä¿å­˜æ–‡ä»¶å…ƒæ•°æ®åˆ°æ•°æ®åº“
                FileMetadata metadata = FileMetadata.builder()
                    .fileId(fileId)
                    .fileName(file.getOriginalFilename())
                    .fileSize(file.getSize())
                    .contentType(file.getContentType())
                    .bucket(defaultBucket)
                    .objectName(objectName)
                    .userId(UserContextHolder.getUserId())
                    .tags(options.getTags())
                    .expiresAt(options.getExpiresAt())
                    .build();
                    
                metadataService.save(metadata);
                
                // ç”Ÿæˆè®¿é—®URL
                String url = generatePresignedUrl(objectName, options.getUrlExpiry());
                
                return StorageResult.builder()
                    .fileId(fileId)
                    .url(url)
                    .size(file.getSize())
                    .build();
                    
            } catch (Exception e) {
                throw new AdapterException("Upload failed", e);
            }
        }, 3);
    }
    
    // æ–‡ä»¶é¢„å¤„ç†ï¼ˆå‹ç¼©ã€åŠ å¯†ç­‰ï¼‰
    private InputStream preprocessFile(MultipartFile file, UploadOptions options) throws IOException {
        InputStream stream = file.getInputStream();
        
        // å›¾ç‰‡å‹ç¼©
        if (options.isCompressImage() && isImage(file.getContentType())) {
            stream = compressImage(stream, options.getQuality());
        }
        
        // æ–‡ä»¶åŠ å¯†
        if (options.isEncrypt()) {
            stream = encryptStream(stream, options.getEncryptionKey());
        }
        
        // ç—…æ¯’æ‰«æ
        if (options.isVirusScan()) {
            scanForVirus(stream);
        }
        
        return stream;
    }
    
    // åˆ†ç‰‡ä¸Šä¼ 
    public String initiateMultipartUpload(MultipartUploadRequest request) {
        String uploadId = UUID.randomUUID().toString();
        
        // åˆå§‹åŒ–åˆ†ç‰‡ä¸Šä¼ ä¼šè¯
        MultipartUploadSession session = MultipartUploadSession.builder()
            .uploadId(uploadId)
            .fileName(request.getFileName())
            .totalParts(request.getTotalParts())
            .partSize(request.getPartSize())
            .build();
            
        uploadSessionCache.put(uploadId, session);
        
        return uploadId;
    }
    
    // ä¸Šä¼ åˆ†ç‰‡
    public PartUploadResult uploadPart(String uploadId, int partNumber, InputStream partData) {
        MultipartUploadSession session = uploadSessionCache.get(uploadId);
        
        if (session == null) {
            throw new IllegalArgumentException("Invalid upload ID");
        }
        
        return executeWithRetry(client -> {
            try {
                // ä¸Šä¼ åˆ†ç‰‡åˆ°ä¸´æ—¶ä½ç½®
                String partKey = String.format("temp/%s/part-%d", uploadId, partNumber);
                
                client.putObject(
                    PutObjectArgs.builder()
                        .bucket(defaultBucket)
                        .object(partKey)
                        .stream(partData, -1, 10485760)
                        .build()
                );
                
                // æ›´æ–°ä¼šè¯
                session.addCompletedPart(partNumber);
                
                return PartUploadResult.builder()
                    .partNumber(partNumber)
                    .etag(DigestUtils.md5Hex(partData))
                    .build();
                    
            } catch (Exception e) {
                throw new AdapterException("Part upload failed", e);
            }
        }, 3);
    }
    
    // æ–‡ä»¶ä¸‹è½½ï¼ˆå¸¦æƒé™æ§åˆ¶ï¼‰
    public InputStream downloadFile(String fileId) {
        // æ£€æŸ¥æƒé™
        FileMetadata metadata = metadataService.getByFileId(fileId);
        checkDownloadPermission(metadata);
        
        return execute(client -> {
            try {
                GetObjectResponse response = client.getObject(
                    GetObjectArgs.builder()
                        .bucket(metadata.getBucket())
                        .object(metadata.getObjectName())
                        .build()
                );
                
                // è®°å½•ä¸‹è½½æ—¥å¿—
                auditService.logDownload(fileId, UserContextHolder.getUserId());
                
                // å¦‚æœæ–‡ä»¶åŠ å¯†ï¼Œè¿›è¡Œè§£å¯†
                if (metadata.isEncrypted()) {
                    return decryptStream(response);
                }
                
                return response;
                
            } catch (Exception e) {
                throw new AdapterException("Download failed", e);
            }
        });
    }
    
    // æ‰¹é‡æ“ä½œ
    @Async
    public CompletableFuture<BatchOperationResult> batchDelete(List<String> fileIds) {
        return CompletableFuture.supplyAsync(() -> {
            List<DeleteObject> objects = fileIds.stream()
                .map(fileId -> {
                    FileMetadata metadata = metadataService.getByFileId(fileId);
                    return new DeleteObject(metadata.getObjectName());
                })
                .collect(Collectors.toList());
                
            Iterable<Result<DeleteError>> results = minioClient.removeObjects(
                RemoveObjectsArgs.builder()
                    .bucket(defaultBucket)
                    .objects(objects)
                    .build()
            );
            
            // ç»Ÿè®¡ç»“æœ
            int successCount = 0;
            int failureCount = 0;
            
            for (Result<DeleteError> result : results) {
                try {
                    result.get();
                    failureCount++;
                } catch (Exception e) {
                    successCount++;
                }
            }
            
            // åˆ é™¤å…ƒæ•°æ®
            metadataService.deleteByFileIds(fileIds);
            
            return BatchOperationResult.builder()
                .totalCount(fileIds.size())
                .successCount(successCount)
                .failureCount(failureCount)
                .build();
        });
    }
}
```

### 3.3 MQTT/IoTé€‚é…å™¨æœåŠ¡

```java
// MQTTé€‚é…å™¨æœåŠ¡
@Service
@Slf4j
public class MqttAdapterService extends BaseAdapterService<MqttClient, MessageResult> {
    
    @Autowired
    private MqttClient mqttClient;
    
    @Autowired
    private DeviceRegistry deviceRegistry;
    
    @Autowired
    private MessageProcessor messageProcessor;
    
    // è®¾å¤‡æ¶ˆæ¯è®¢é˜…ç®¡ç†
    private final Map<String, Set<String>> subscriptions = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void init() {
        // è®¾ç½®æ¶ˆæ¯å›è°ƒ
        mqttClient.setCallback(new MqttCallback() {
            @Override
            public void messageArrived(String topic, MqttMessage message) {
                handleIncomingMessage(topic, message);
            }
            
            @Override
            public void connectionLost(Throwable cause) {
                log.error("MQTT connection lost", cause);
                reconnect();
            }
            
            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {
                log.debug("Message delivered: {}", token.getMessageId());
            }
        });
        
        // è®¢é˜…ç³»ç»Ÿä¸»é¢˜
        subscribeSystemTopics();
    }
    
    // å‘é€è®¾å¤‡æ§åˆ¶æŒ‡ä»¤
    public MessageResult sendCommand(DeviceCommand command) {
        return executeWithRetry(client -> {
            try {
                // éªŒè¯è®¾å¤‡çŠ¶æ€
                Device device = deviceRegistry.getDevice(command.getDeviceId());
                if (!device.isOnline()) {
                    throw new DeviceOfflineException("Device is offline");
                }
                
                // æ„å»ºMQTTæ¶ˆæ¯
                String topic = buildCommandTopic(device);
                MqttMessage message = new MqttMessage();
                
                // è®¾ç½®æ¶ˆæ¯å†…å®¹
                CommandPayload payload = CommandPayload.builder()
                    .commandId(UUID.randomUUID().toString())
                    .deviceId(command.getDeviceId())
                    .action(command.getAction())
                    .params(command.getParams())
                    .timestamp(System.currentTimeMillis())
                    .build();
                    
                message.setPayload(JsonUtils.toJson(payload).getBytes());
                message.setQos(command.getQos() != null ? command.getQos() : 1);
                message.setRetained(false);
                
                // å‘é€æ¶ˆæ¯
                client.publish(topic, message);
                
                // è®°å½•å‘½ä»¤æ—¥å¿—
                commandLogService.log(CommandLog.builder()
                    .commandId(payload.getCommandId())
                    .deviceId(command.getDeviceId())
                    .userId(UserContextHolder.getUserId())
                    .action(command.getAction())
                    .status(CommandStatus.SENT)
                    .build());
                
                // ç­‰å¾…å“åº”ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (command.isWaitResponse()) {
                    return waitForResponse(payload.getCommandId(), command.getTimeout());
                }
                
                return MessageResult.success(payload.getCommandId());
                
            } catch (Exception e) {
                throw new AdapterException("Send command failed", e);
            }
        }, 3);
    }
    
    // å¤„ç†è®¾å¤‡ä¸ŠæŠ¥æ•°æ®
    private void handleIncomingMessage(String topic, MqttMessage message) {
        try {
            // è§£æä¸»é¢˜
            TopicInfo topicInfo = parseTopicInfo(topic);
            
            // è§£ææ¶ˆæ¯å†…å®¹
            String payload = new String(message.getPayload());
            
            // æ ¹æ®æ¶ˆæ¯ç±»å‹å¤„ç†
            switch (topicInfo.getMessageType()) {
                case TELEMETRY:
                    handleTelemetry(topicInfo.getDeviceId(), payload);
                    break;
                case STATUS:
                    handleStatusUpdate(topicInfo.getDeviceId(), payload);
                    break;
                case ALERT:
                    handleAlert(topicInfo.getDeviceId(), payload);
                    break;
                case RESPONSE:
                    handleCommandResponse(topicInfo.getDeviceId(), payload);
                    break;
                default:
                    log.warn("Unknown message type: {}", topicInfo.getMessageType());
            }
            
        } catch (Exception e) {
            log.error("Failed to process message from topic: {}", topic, e);
        }
    }
    
    // å¤„ç†é¥æµ‹æ•°æ®
    private void handleTelemetry(String deviceId, String payload) {
        TelemetryData telemetry = JsonUtils.fromJson(payload, TelemetryData.class);
        
        // æ•°æ®éªŒè¯
        if (!validateTelemetry(telemetry)) {
            log.warn("Invalid telemetry data from device: {}", deviceId);
            return;
        }
        
        // æ•°æ®å¤„ç†
        ProcessedTelemetry processed = messageProcessor.processTelemetry(deviceId, telemetry);
        
        // å­˜å‚¨åˆ°æ—¶åºæ•°æ®åº“
        timeSeriesService.save(deviceId, processed);
        
        // è§¦å‘è§„åˆ™å¼•æ“
        ruleEngine.evaluate(deviceId, processed);
        
        // å‘é€åˆ°äº‹ä»¶æ€»çº¿
        eventBus.publish(new TelemetryEvent(deviceId, processed));
    }
    
    // è®¾å¤‡æ³¨å†Œ
    public DeviceRegistrationResult registerDevice(DeviceRegistrationRequest request) {
        // ç”Ÿæˆè®¾å¤‡è¯ä¹¦
        DeviceCredentials credentials = generateDeviceCredentials(request);
        
        // æ³¨å†Œè®¾å¤‡
        Device device = Device.builder()
            .deviceId(request.getDeviceId())
            .deviceType(request.getDeviceType())
            .metadata(request.getMetadata())
            .credentials(credentials)
            .status(DeviceStatus.REGISTERED)
            .build();
            
        deviceRegistry.register(device);
        
        // è®¢é˜…è®¾å¤‡ä¸»é¢˜
        subscribeDeviceTopics(device.getDeviceId());
        
        return DeviceRegistrationResult.builder()
            .deviceId(device.getDeviceId())
            .mqttEndpoint(getMqttEndpoint())
            .topics(getDeviceTopics(device.getDeviceId()))
            .credentials(credentials)
            .build();
    }
    
    // æ‰¹é‡è®¾å¤‡ç®¡ç†
    public BatchResult batchControl(BatchControlRequest request) {
        List<CompletableFuture<MessageResult>> futures = request.getDeviceIds()
            .stream()
            .map(deviceId -> CompletableFuture.supplyAsync(() -> {
                try {
                    DeviceCommand command = DeviceCommand.builder()
                        .deviceId(deviceId)
                        .action(request.getAction())
                        .params(request.getParams())
                        .build();
                    return sendCommand(command);
                } catch (Exception e) {
                    return MessageResult.failure(e.getMessage());
                }
            }))
            .collect(Collectors.toList());
            
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        
        List<MessageResult> results = futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
            
        long successCount = results.stream()
            .filter(MessageResult::isSuccess)
            .count();
            
        return BatchResult.builder()
            .totalCount(request.getDeviceIds().size())
            .successCount(successCount)
            .failureCount(request.getDeviceIds().size() - successCount)
            .details(results)
            .build();
    }
}
```

### 3.4 AIæ¨¡å‹é€‚é…å™¨æœåŠ¡ï¼ˆOllamaï¼‰

```java
// Ollama AIé€‚é…å™¨æœåŠ¡
@Service
@Slf4j
public class OllamaAdapterService extends BaseAdapterService<OllamaClient, AIResponse> {
    
    @Autowired
    private OllamaClient ollamaClient;
    
    @Autowired
    private PromptTemplateService templateService;
    
    @Autowired
    private TokenCounter tokenCounter;
    
    // æ–‡æœ¬ç”Ÿæˆ
    public AIResponse generate(GenerateRequest request) {
        return executeWithRetry(client -> {
            // åŠ è½½æç¤ºè¯æ¨¡æ¿
            String prompt = preparePrompt(request);
            
            // æ£€æŸ¥tokené™åˆ¶
            int tokenCount = tokenCounter.count(prompt);
            if (tokenCount > request.getMaxTokens()) {
                throw new TokenLimitExceededException("Prompt exceeds token limit");
            }
            
            // æ„å»ºè¯·æ±‚
            OllamaGenerateRequest ollamaRequest = OllamaGenerateRequest.builder()
                .model(request.getModel() != null ? request.getModel() : "llama2")
                .prompt(prompt)
                .temperature(request.getTemperature())
                .topP(request.getTopP())
                .maxTokens(request.getMaxTokens())
                .stream(false)
                .build();
            
            // è°ƒç”¨æ¨¡å‹
            OllamaResponse response = client.generate(ollamaRequest);
            
            // è½¬æ¢å“åº”
            return AIResponse.builder()
                .content(response.getResponse())
                .model(request.getModel())
                .usage(Usage.builder()
                    .promptTokens(tokenCount)
                    .completionTokens(tokenCounter.count(response.getResponse()))
                    .build())
                .metadata(Map.of(
                    "duration", response.getDuration(),
                    "model_version", response.getModelVersion()
                ))
                .build();
                
        }, 3);
    }
    
    // å¯¹è¯
    public AIResponse chat(ChatRequest request) {
        return executeWithRetry(client -> {
            // æ„å»ºå¯¹è¯ä¸Šä¸‹æ–‡
            List<Message> messages = buildChatContext(request);
            
            // è°ƒç”¨èŠå¤©API
            OllamaChatRequest chatRequest = OllamaChatRequest.builder()
                .model(request.getModel())
                .messages(messages)
                .temperature(request.getTemperature())
                .build();
                
            OllamaChatResponse response = client.chat(chatRequest);
            
            // ä¿å­˜å¯¹è¯å†å²
            saveChatHistory(request.getSessionId(), messages, response);
            
            return AIResponse.builder()
                .content(response.getMessage().getContent())
                .role(response.getMessage().getRole())
                .sessionId(request.getSessionId())
                .build();
        }, 3);
    }
    
    // åµŒå…¥å‘é‡ç”Ÿæˆ
    public EmbeddingResponse generateEmbedding(EmbeddingRequest request) {
        return executeWithRetry(client -> {
            OllamaEmbeddingRequest embeddingRequest = OllamaEmbeddingRequest.builder()
                .model("nomic-embed-text")
                .prompt(request.getText())
                .build();
                
            OllamaEmbeddingResponse response = client.embedding(embeddingRequest);
            
            return EmbeddingResponse.builder()
                .embedding(response.getEmbedding())
                .dimension(response.getEmbedding().length)
                .build();
        }, 3);
    }
    
    // æµå¼ç”Ÿæˆ
    public Flux<String> streamGenerate(GenerateRequest request) {
        String prompt = preparePrompt(request);
        
        OllamaGenerateRequest ollamaRequest = OllamaGenerateRequest.builder()
            .model(request.getModel())
            .prompt(prompt)
            .stream(true)
            .build();
            
        return Flux.create(sink -> {
            try {
                ollamaClient.streamGenerate(ollamaRequest, new StreamCallback() {
                    @Override
                    public void onToken(String token) {
                        sink.next(token);
                    }
                    
                    @Override
                    public void onComplete() {
                        sink.complete();
                    }
                    
                    @Override
                    public void onError(Exception e) {
                        sink.error(e);
                    }
                });
            } catch (Exception e) {
                sink.error(e);
            }
        });
    }
}
```

## ğŸ“ å››ã€é€‚é…å™¨æœåŠ¡é…ç½®

### 4.1 ç»Ÿä¸€é…ç½®æ¨¡æ¿

```yaml
# application-base.yml
spring:
  application:
    name: ${SERVICE_NAME}-adapter
    
  cloud:
    nacos:
      discovery:
        server-addr: ${NACOS_SERVER:localhost:8848}
        namespace: ${NACOS_NAMESPACE:haven-platform}
        group: adapter-services
        
server:
  port: ${SERVER_PORT:8080}
  
# é€‚é…å™¨é€šç”¨é…ç½®
adapter:
  # é‡è¯•é…ç½®
  retry:
    max-attempts: 3
    backoff:
      initial-interval: 1000
      max-interval: 30000
      multiplier: 2
      
  # è¿æ¥æ± é…ç½®
  pool:
    max-total: 100
    max-per-route: 20
    connection-timeout: 5000
    socket-timeout: 10000
    
  # ç†”æ–­å™¨é…ç½®
  circuit-breaker:
    failure-threshold: 50
    success-threshold: 5
    timeout: 30000
    
  # ç›‘æ§é…ç½®
  metrics:
    enabled: true
    export:
      prometheus:
        enabled: true
        
# å¥åº·æ£€æŸ¥
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  health:
    defaults:
      enabled: true
    custom:
      enabled: true
      
# æ—¥å¿—é…ç½®
logging:
  level:
    root: INFO
    com.haven.adapter: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    
# ç‰¹å®šæœåŠ¡é…ç½®ï¼ˆä»¥ESä¸ºä¾‹ï¼‰
elasticsearch:
  hosts: ${ES_HOSTS:localhost:9200}
  username: ${ES_USERNAME:}
  password: ${ES_PASSWORD:}
  connection-timeout: 5000
  socket-timeout: 30000
  max-retry-timeout: 30000
```

### 4.2 DockeråŒ–éƒ¨ç½²

```dockerfile
# Dockerfileæ¨¡æ¿
FROM openjdk:17-jdk-slim

WORKDIR /app

# æ·»åŠ å¥åº·æ£€æŸ¥è„šæœ¬
COPY health-check.sh /health-check.sh
RUN chmod +x /health-check.sh

# å¤åˆ¶JARæ–‡ä»¶
COPY target/*-adapter.jar app.jar

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD /health-check.sh || exit 1

# å¯åŠ¨å‘½ä»¤
ENTRYPOINT ["java", "-jar", "/app/app.jar"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  # ESé€‚é…å™¨
  es-adapter:
    image: haven/es-adapter:latest
    environment:
      - SERVICE_NAME=elasticsearch
      - ES_HOSTS=elasticsearch:9200
      - NACOS_SERVER=nacos:8848
    depends_on:
      - elasticsearch
      - nacos
    networks:
      - haven-network
      
  # MinIOé€‚é…å™¨
  storage-adapter:
    image: haven/storage-adapter:latest
    environment:
      - SERVICE_NAME=storage
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=admin
      - MINIO_SECRET_KEY=admin123
    depends_on:
      - minio
      - nacos
    networks:
      - haven-network
      
  # MQTTé€‚é…å™¨
  iot-adapter:
    image: haven/iot-adapter:latest
    environment:
      - SERVICE_NAME=iot
      - MQTT_BROKER=tcp://emqx:1883
      - MQTT_USERNAME=admin
      - MQTT_PASSWORD=admin123
    depends_on:
      - emqx
      - nacos
    networks:
      - haven-network
      
  # AIé€‚é…å™¨
  ai-adapter:
    image: haven/ai-adapter:latest
    environment:
      - SERVICE_NAME=ai
      - OLLAMA_HOST=http://ollama:11434
    depends_on:
      - ollama
      - nacos
    networks:
      - haven-network

networks:
  haven-network:
    driver: bridge
```

## ğŸ”„ äº”ã€æœåŠ¡æ³¨å†Œä¸å‘ç°

### 5.1 è‡ªåŠ¨æ³¨å†Œæœºåˆ¶

```java
// é€‚é…å™¨æœåŠ¡è‡ªåŠ¨æ³¨å†Œ
@Component
@Slf4j
public class AdapterServiceRegistrar {
    
    @Autowired
    private NacosServiceRegistry registry;
    
    @Autowired
    private AdapterProperties properties;
    
    @PostConstruct
    public void register() {
        // æ„å»ºæœåŠ¡å®ä¾‹
        NacosServiceInstance instance = NacosServiceInstance.builder()
            .serviceId(properties.getServiceId())
            .host(getLocalHost())
            .port(properties.getPort())
            .secure(false)
            .metadata(Map.of(
                "adapter.type", properties.getAdapterType(),
                "adapter.version", properties.getVersion(),
                "adapter.target", properties.getTargetService()
            ))
            .build();
            
        // æ³¨å†ŒæœåŠ¡
        registry.register(instance);
        
        // æ³¨å†Œå¥åº·æ£€æŸ¥
        registry.setStatus(instance, "UP");
        
        log.info("Adapter service registered: {}", instance.getServiceId());
    }
    
    @PreDestroy
    public void deregister() {
        registry.deregister(buildServiceInstance());
        log.info("Adapter service deregistered");
    }
}
```

### 5.2 GatewayåŠ¨æ€è·¯ç”±

```java
// GatewayåŠ¨æ€å‘ç°é€‚é…å™¨æœåŠ¡
@Component
public class AdapterRouteLocator {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @Scheduled(fixedDelay = 30000)
    public void refreshRoutes() {
        // å‘ç°æ‰€æœ‰é€‚é…å™¨æœåŠ¡
        List<ServiceInstance> adapters = discoveryClient.getInstances("adapter-services");
        
        adapters.forEach(adapter -> {
            String adapterType = adapter.getMetadata().get("adapter.type");
            
            // åŠ¨æ€åˆ›å»ºè·¯ç”±
            Route route = Route.builder()
                .id("adapter-" + adapterType)
                .uri("lb://" + adapter.getServiceId())
                .predicate(PathPredicateFactory.apply("/api/" + adapterType + "/**"))
                .filter(StripPrefixGatewayFilterFactory.apply(2))
                .build();
                
            routeRegistry.add(route);
        });
    }
}
```

## ğŸ“Š å…­ã€ç›‘æ§ä¸ç®¡ç†

### 6.1 é€‚é…å™¨ç›‘æ§æŒ‡æ ‡

```java
// é€‚é…å™¨ç›‘æ§æŒ‡æ ‡æ”¶é›†
@Component
public class AdapterMetricsCollector {
    
    private final MeterRegistry registry;
    
    // è°ƒç”¨è®¡æ•°
    private final Counter callCounter;
    
    // å“åº”æ—¶é—´
    private final Timer responseTimer;
    
    // é”™è¯¯ç‡
    private final Counter errorCounter;
    
    // è¿æ¥æ± çŠ¶æ€
    private final Gauge poolGauge;
    
    public AdapterMetricsCollector(MeterRegistry registry) {
        this.registry = registry;
        
        this.callCounter = Counter.builder("adapter.calls")
            .description("Total adapter calls")
            .register(registry);
            
        this.responseTimer = Timer.builder("adapter.response.time")
            .description("Adapter response time")
            .register(registry);
            
        this.errorCounter = Counter.builder("adapter.errors")
            .description("Total adapter errors")
            .register(registry);
            
        this.poolGauge = Gauge.builder("adapter.pool.active", this, 
            AdapterMetricsCollector::getActiveConnections)
            .description("Active connections in pool")
            .register(registry);
    }
    
    @EventListener
    public void handleAdapterCall(AdapterCallEvent event) {
        callCounter.increment();
        
        Timer.Sample sample = Timer.start(registry);
        
        event.onComplete(result -> {
            sample.stop(responseTimer);
            
            if (!result.isSuccess()) {
                errorCounter.increment();
            }
        });
    }
}
```

### 6.2 Vueç®¡ç†ç«¯é›†æˆ

```vue
<!-- é€‚é…å™¨æœåŠ¡ç®¡ç†ç•Œé¢ -->
<template>
  <div class="adapter-manager">
    <el-card>
      <template #header>
        <div class="card-header">
          <span>é€‚é…å™¨æœåŠ¡åˆ—è¡¨</span>
          <el-button type="primary" @click="showRegisterDialog">
            æ³¨å†Œæ–°é€‚é…å™¨
          </el-button>
        </div>
      </template>
      
      <el-table :data="adapters" style="width: 100%">
        <el-table-column prop="name" label="é€‚é…å™¨åç§°" />
        <el-table-column prop="type" label="ç±»å‹">
          <template #default="scope">
            <el-tag>{{ scope.row.type }}</el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="targetService" label="ç›®æ ‡æœåŠ¡" />
        <el-table-column prop="status" label="çŠ¶æ€">
          <template #default="scope">
            <el-badge 
              :type="scope.row.status === 'UP' ? 'success' : 'danger'"
              :value="scope.row.status" />
          </template>
        </el-table-column>
        <el-table-column label="ç›‘æ§æŒ‡æ ‡">
          <template #default="scope">
            <div class="metrics">
              <span>è°ƒç”¨æ¬¡æ•°: {{ scope.row.metrics.calls }}</span>
              <span>å¹³å‡å“åº”: {{ scope.row.metrics.avgResponse }}ms</span>
              <span>é”™è¯¯ç‡: {{ scope.row.metrics.errorRate }}%</span>
            </div>
          </template>
        </el-table-column>
        <el-table-column label="æ“ä½œ">
          <template #default="scope">
            <el-button-group>
              <el-button size="small" @click="viewConfig(scope.row)">
                é…ç½®
              </el-button>
              <el-button size="small" @click="viewMonitor(scope.row)">
                ç›‘æ§
              </el-button>
              <el-button size="small" @click="testAdapter(scope.row)">
                æµ‹è¯•
              </el-button>
            </el-button-group>
          </template>
        </el-table-column>
      </el-table>
    </el-card>
    
    <!-- é€‚é…å™¨æµ‹è¯•å¯¹è¯æ¡† -->
    <el-dialog v-model="testDialog" title="æµ‹è¯•é€‚é…å™¨" width="60%">
      <AdapterTestPanel :adapter="currentAdapter" />
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { getAdapters, testAdapter } from '@/api/adapter'
import AdapterTestPanel from './AdapterTestPanel.vue'

const adapters = ref([])
const currentAdapter = ref(null)
const testDialog = ref(false)

const loadAdapters = async () => {
  const res = await getAdapters()
  adapters.value = res.data
}

const testAdapter = (adapter) => {
  currentAdapter.value = adapter
  testDialog.value = true
}

onMounted(() => {
  loadAdapters()
  // å®šæ—¶åˆ·æ–°
  setInterval(loadAdapters, 10000)
})
</script>
```

## ğŸš€ ä¸ƒã€æœ€ä½³å®è·µ

### 7.1 é€‚é…å™¨å¼€å‘è§„èŒƒ

1. **ç»Ÿä¸€å¼‚å¸¸å¤„ç†**ï¼šæ‰€æœ‰å¼‚å¸¸è½¬æ¢ä¸ºå¹³å°æ ‡å‡†å¼‚å¸¸
2. **ç»Ÿä¸€æ—¥å¿—æ ¼å¼**ï¼šå¿…é¡»åŒ…å«TraceIdã€æœåŠ¡åã€æ“ä½œç±»å‹
3. **ç»Ÿä¸€ç›‘æ§æŒ‡æ ‡**ï¼šè°ƒç”¨æ¬¡æ•°ã€å“åº”æ—¶é—´ã€é”™è¯¯ç‡ã€è¿æ¥æ± çŠ¶æ€
4. **ç»Ÿä¸€å¥åº·æ£€æŸ¥**ï¼šæ£€æŸ¥ç›®æ ‡æœåŠ¡è¿é€šæ€§ã€è¿æ¥æ± çŠ¶æ€
5. **ç»Ÿä¸€é…ç½®ç®¡ç†**ï¼šé€šè¿‡NacosåŠ¨æ€é…ç½®

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è¿æ¥æ± ä¼˜åŒ–**ï¼šæ ¹æ®è´Ÿè½½åŠ¨æ€è°ƒæ•´è¿æ¥æ± å¤§å°
2. **æ‰¹é‡æ“ä½œ**ï¼šæ”¯æŒæ‰¹é‡APIå‡å°‘ç½‘ç»œå¼€é”€
3. **ç¼“å­˜ç­–ç•¥**ï¼šå¯¹é¢‘ç¹è®¿é—®çš„æ•°æ®è¿›è¡Œç¼“å­˜
4. **å¼‚æ­¥å¤„ç†**ï¼šé•¿è€—æ—¶æ“ä½œä½¿ç”¨å¼‚æ­¥æ–¹å¼
5. **ç†”æ–­é™çº§**ï¼šé˜²æ­¢çº§è”æ•…éšœ

### 7.3 å®‰å…¨åŠ å›º

1. **è®¤è¯æˆæƒ**ï¼šæ‰€æœ‰é€‚é…å™¨å¿…é¡»éªŒè¯è°ƒç”¨æ–¹èº«ä»½
2. **æ•°æ®åŠ å¯†**ï¼šæ•æ„Ÿæ•°æ®ä¼ è¾“åŠ å¯†
3. **å®¡è®¡æ—¥å¿—**ï¼šè®°å½•æ‰€æœ‰æ“ä½œæ—¥å¿—
4. **é™æµæ§åˆ¶**ï¼šé˜²æ­¢æ¶æ„è°ƒç”¨
5. **æ•°æ®è„±æ•**ï¼šæ—¥å¿—ä¸­çš„æ•æ„Ÿä¿¡æ¯è„±æ•

é€šè¿‡è¿™ç§é€‚é…å™¨æ¨¡å¼ï¼Œä½ å¯ä»¥çµæ´»åœ°å°†å„ç§å¼€æºæœåŠ¡é›†æˆåˆ°ä½ çš„JavaæœåŠ¡å¹³å°ä¸­ï¼ŒåŒæ—¶ä¿æŒæ¶æ„çš„æ¸…æ™°å’Œå¯ç»´æŠ¤æ€§ã€‚