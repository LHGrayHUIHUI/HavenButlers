# ç»Ÿä¸€æ—¥å¿—ç³»ç»Ÿè¯¦è§£

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

ç»Ÿä¸€æ—¥å¿—ç³»ç»Ÿæ˜¯ Storage Service åŸºäº base-model æ¨¡å—çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä¸ºæ•´ä¸ª HavenButler å¹³å°æä¾›ç»Ÿä¸€çš„æ—¥å¿—æ”¶é›†ã€å­˜å‚¨ã€åˆ†æå’Œç›‘æ§æœåŠ¡ã€‚æ”¯æŒæ“ä½œã€å®‰å…¨ã€æ€§èƒ½ã€ä¸šåŠ¡ã€é”™è¯¯äº”ç§æ—¥å¿—ç±»å‹çš„å…¨é“¾è·¯è¿½è¸ªã€‚

## ğŸ—ï¸ æ—¥å¿—ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ—¥å¿—æ¶æ„å›¾

```mermaid
graph TB
    subgraph "å¾®æœåŠ¡å±‚"
        A[Account Service]
        B[Message Service]
        C[AI Service]
        D[NLP Service]
        E[File Manager Service]
    end

    subgraph "Base-Model æ—¥å¿—æ¨¡å—"
        F[@LogOperation æ³¨è§£]
        G[LogClient å®¢æˆ·ç«¯]
        H[LogEvent äº‹ä»¶æ¨¡å‹]
        I[LogAspect åˆ‡é¢]
        J[å¼‚æ­¥å¤„ç†å™¨]
    end

    subgraph "Storage Service - æ—¥å¿—ç³»ç»Ÿ"
        K[æ—¥å¿—æ¥æ”¶API]
        L[æ—¥å¿—ç±»å‹è·¯ç”±]
        M[æ•°æ®éªŒè¯å™¨]
        N[æ‰¹é‡å¤„ç†å™¨]
        O[å­˜å‚¨é€‚é…å™¨]
        P[å®æ—¶ç›‘æ§]
    end

    subgraph "æ—¥å¿—å­˜å‚¨å±‚"
        Q[PostgreSQL<br/>ç»“æ„åŒ–æ—¥å¿—]
        R[MongoDB<br/>éç»“æ„åŒ–æ—¥å¿—]
        S[Elasticsearch<br/>æ—¥å¿—æ£€ç´¢]
        T[Redis<br/>å®æ—¶ç»Ÿè®¡]
    end

    A --> F
    A --> G
    B --> F
    B --> G
    C --> F
    C --> G
    D --> F
    D --> G
    E --> F
    E --> G

    F --> I
    G --> H
    I --> J
    H --> J

    J --> K
    K --> L
    L --> M
    M --> N
    N --> O

    O --> Q
    O --> R
    O --> S
    O --> T

    P --> T
```

### æ—¥å¿—ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶

#### 1. Base-Model æ—¥å¿—æ¨¡å—
- **@LogOperation æ³¨è§£**: å£°æ˜å¼æ—¥å¿—è®°å½•
- **LogClient**: ç¼–ç¨‹å¼æ—¥å¿—å®¢æˆ·ç«¯
- **LogEvent**: ç»Ÿä¸€æ—¥å¿—äº‹ä»¶æ¨¡å‹
- **LogAspect**: AOP åˆ‡é¢å¤„ç†å™¨

#### 2. Storage Service æ—¥å¿—æ¥æ”¶å±‚
- **æ—¥å¿—æ¥æ”¶API**: ç»Ÿä¸€çš„HTTPæ¥å£
- **ç±»å‹è·¯ç”±å™¨**: æ ¹æ®æ—¥å¿—ç±»å‹åˆ†å‘
- **æ•°æ®éªŒè¯å™¨**: æ—¥å¿—æ•°æ®æ ¼å¼éªŒè¯
- **æ‰¹é‡å¤„ç†å™¨**: é«˜æ€§èƒ½æ‰¹é‡å¤„ç†

#### 3. æ—¥å¿—å­˜å‚¨é€‚é…å±‚
- **PostgreSQL**: å…³é”®ä¸šåŠ¡æ—¥å¿—ç»“æ„åŒ–å­˜å‚¨
- **MongoDB**: å¤§é‡è®¾å¤‡æ—¥å¿—éç»“æ„åŒ–å­˜å‚¨
- **Elasticsearch**: å…¨æ–‡æ£€ç´¢å’Œæ—¥å¿—åˆ†æ
- **Redis**: å®æ—¶ç»Ÿè®¡å’Œç¼“å­˜

## ğŸ”§ æ—¥å¿—æŠ€æœ¯å®ç°

### ç»Ÿä¸€æ—¥å¿—äº‹ä»¶æ¨¡å‹

```java
/**
 * ç»Ÿä¸€æ—¥å¿—äº‹ä»¶æ¨¡å‹ - Base-Model
 */
public class LogEvent {
    private String traceId;              // é“¾è·¯è¿½è¸ªID
    private String familyId;             // å®¶åº­ID
    private String userId;               // ç”¨æˆ·ID
    private String serviceId;            // æœåŠ¡ID
    private LogType logType;             // æ—¥å¿—ç±»å‹
    private String operationType;        // æ“ä½œç±»å‹
    private String description;          // æ“ä½œæè¿°
    private Long timestamp;              // æ—¶é—´æˆ³
    private Long executionTime;          // æ‰§è¡Œè€—æ—¶
    private RiskLevel riskLevel;         // é£é™©ç­‰çº§
    private String clientIp;            // å®¢æˆ·ç«¯IP
    private String userAgent;           // ç”¨æˆ·ä»£ç†
    private Map<String, Object> extraData; // æ‰©å±•æ•°æ®
    private String errorMessage;        // é”™è¯¯ä¿¡æ¯
    private String stackTrace;          // å †æ ˆä¿¡æ¯

    /**
     * æ—¥å¿—ç±»å‹æšä¸¾
     */
    public enum LogType {
        OPERATION("æ“ä½œæ—¥å¿—"),    // ç”¨æˆ·æ“ä½œè®°å½•
        SECURITY("å®‰å…¨æ—¥å¿—"),     // å®‰å…¨äº‹ä»¶è®°å½•
        PERFORMANCE("æ€§èƒ½æ—¥å¿—"),  // æ€§èƒ½ç›‘æ§è®°å½•
        BUSINESS("ä¸šåŠ¡æ—¥å¿—"),     // ä¸šåŠ¡æµç¨‹è®°å½•
        ERROR("é”™è¯¯æ—¥å¿—");        // å¼‚å¸¸é”™è¯¯è®°å½•

        private final String description;
    }

    /**
     * é£é™©ç­‰çº§æšä¸¾
     */
    public enum RiskLevel {
        LOW("ä½é£é™©"),
        MEDIUM("ä¸­é£é™©"),
        HIGH("é«˜é£é™©"),
        CRITICAL("ä¸¥é‡é£é™©");

        private final String description;
    }
}
```

### æ—¥å¿—æ¥æ”¶APIå®ç°

```java
/**
 * ç»Ÿä¸€æ—¥å¿—æ¥æ”¶æ§åˆ¶å™¨ - Storage Service
 */
@RestController
@RequestMapping("/api/v1/logs")
@Slf4j
public class LogReceiveController {

    private final LogEventService logEventService;
    private final LogValidator logValidator;
    private final LogMetricsCollector metricsCollector;

    /**
     * ç»Ÿä¸€æ—¥å¿—æ¥æ”¶å…¥å£
     */
    @PostMapping("/unified")
    public CompletableFuture<ApiResponse<String>> receiveLog(
            @RequestBody LogEvent logEvent,
            @RequestHeader("X-Family-ID") String familyId,
            @RequestHeader("X-Trace-ID") String traceId) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. åŸºç¡€éªŒè¯
                logValidator.validate(logEvent, familyId, traceId);

                // 2. è¡¥å……ç³»ç»Ÿä¿¡æ¯
                enrichLogEvent(logEvent, familyId, traceId);

                // 3. å¼‚æ­¥å¤„ç†æ—¥å¿—
                logEventService.processLogAsync(logEvent);

                // 4. æ›´æ–°å®æ—¶æŒ‡æ ‡
                metricsCollector.updateMetrics(logEvent);

                return ApiResponse.success("æ—¥å¿—æ¥æ”¶æˆåŠŸ");

            } catch (Exception e) {
                log.error("æ—¥å¿—æ¥æ”¶å¤±è´¥: traceId={}, error={}", traceId, e.getMessage(), e);
                return ApiResponse.error("æ—¥å¿—æ¥æ”¶å¤±è´¥: " + e.getMessage());
            }
        });
    }

    /**
     * æŒ‰ç±»å‹æ¥æ”¶æ—¥å¿—
     */
    @PostMapping("/{logType}")
    public CompletableFuture<ApiResponse<String>> receiveLogByType(
            @PathVariable LogEvent.LogType logType,
            @RequestBody LogEvent logEvent,
            @RequestHeader("X-Family-ID") String familyId,
            @RequestHeader("X-Trace-ID") String traceId) {

        logEvent.setLogType(logType);
        return receiveLog(logEvent, familyId, traceId);
    }

    /**
     * æ‰¹é‡æ—¥å¿—æ¥æ”¶
     */
    @PostMapping("/{logType}/batch")
    public CompletableFuture<ApiResponse<BatchResult>> receiveBatchLogs(
            @PathVariable LogEvent.LogType logType,
            @RequestBody List<LogEvent> logEvents,
            @RequestHeader("X-Family-ID") String familyId,
            @RequestHeader("X-Trace-ID") String traceId) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                // è®¾ç½®æ—¥å¿—ç±»å‹
                logEvents.forEach(event -> event.setLogType(logType));

                // æ‰¹é‡éªŒè¯
                List<LogEvent> validEvents = logValidator.validateBatch(logEvents, familyId);

                // æ‰¹é‡å¤„ç†
                BatchResult result = logEventService.processBatchAsync(validEvents);

                return ApiResponse.success(result);

            } catch (Exception e) {
                log.error("æ‰¹é‡æ—¥å¿—æ¥æ”¶å¤±è´¥: traceId={}, count={}, error={}",
                         traceId, logEvents.size(), e.getMessage(), e);
                return ApiResponse.error("æ‰¹é‡æ—¥å¿—æ¥æ”¶å¤±è´¥: " + e.getMessage());
            }
        });
    }

    private void enrichLogEvent(LogEvent logEvent, String familyId, String traceId) {
        if (StringUtils.isEmpty(logEvent.getFamilyId())) {
            logEvent.setFamilyId(familyId);
        }
        if (StringUtils.isEmpty(logEvent.getTraceId())) {
            logEvent.setTraceId(traceId);
        }
        if (logEvent.getTimestamp() == null) {
            logEvent.setTimestamp(System.currentTimeMillis());
        }
    }
}
```

### æ—¥å¿—å¤„ç†æœåŠ¡å®ç°

```java
/**
 * æ—¥å¿—äº‹ä»¶å¤„ç†æœåŠ¡
 */
@Service
@Slf4j
public class LogEventService {

    private final LogStorageRouter storageRouter;
    private final LogRealTimeProcessor realTimeProcessor;
    private final LogAlertManager alertManager;

    /**
     * å¼‚æ­¥å¤„ç†å•ä¸ªæ—¥å¿—äº‹ä»¶
     */
    @Async("logProcessorExecutor")
    public CompletableFuture<Void> processLogAsync(LogEvent logEvent) {
        return CompletableFuture.runAsync(() -> {
            try {
                // 1. ç¡®å®šå­˜å‚¨ç­–ç•¥
                StorageStrategy strategy = determineStorageStrategy(logEvent);

                // 2. è·¯ç”±åˆ°å¯¹åº”å­˜å‚¨
                storageRouter.route(logEvent, strategy);

                // 3. å®æ—¶å¤„ç†ï¼ˆå‘Šè­¦ã€ç»Ÿè®¡ï¼‰
                realTimeProcessor.process(logEvent);

                // 4. é£é™©æ£€æµ‹å’Œå‘Šè­¦
                if (isHighRisk(logEvent)) {
                    alertManager.sendAlert(logEvent);
                }

            } catch (Exception e) {
                log.error("æ—¥å¿—å¤„ç†å¤±è´¥: traceId={}, error={}",
                         logEvent.getTraceId(), e.getMessage(), e);

                // è®°å½•å¤„ç†å¤±è´¥çš„æ—¥å¿—åˆ°æ­»ä¿¡é˜Ÿåˆ—
                sendToDeadLetterQueue(logEvent, e);
            }
        });
    }

    /**
     * æ‰¹é‡å¼‚æ­¥å¤„ç†æ—¥å¿—äº‹ä»¶
     */
    @Async("logBatchProcessorExecutor")
    public CompletableFuture<BatchResult> processBatchAsync(List<LogEvent> logEvents) {
        return CompletableFuture.supplyAsync(() -> {
            BatchResult result = new BatchResult();

            // æŒ‰æ—¥å¿—ç±»å‹åˆ†ç»„
            Map<LogEvent.LogType, List<LogEvent>> groupedLogs =
                logEvents.stream().collect(Collectors.groupingBy(LogEvent::getLogType));

            // å¹¶è¡Œå¤„ç†æ¯ç§ç±»å‹
            groupedLogs.entrySet().parallelStream()
                .forEach(entry -> {
                    try {
                        int processed = processBatchByType(entry.getKey(), entry.getValue());
                        result.addSuccess(entry.getKey(), processed);
                    } catch (Exception e) {
                        result.addFailure(entry.getKey(), entry.getValue().size(), e);
                    }
                });

            return result;
        });
    }

    private StorageStrategy determineStorageStrategy(LogEvent logEvent) {
        return switch (logEvent.getLogType()) {
            case OPERATION -> StorageStrategy.builder()
                .primaryStorage(StorageType.POSTGRESQL)
                .secondaryStorage(StorageType.ELASTICSEARCH)
                .enableRealTime(true)
                .build();

            case SECURITY -> StorageStrategy.builder()
                .primaryStorage(StorageType.POSTGRESQL)
                .secondaryStorage(StorageType.ELASTICSEARCH)
                .enableRealTime(true)
                .enableAlert(true)
                .build();

            case PERFORMANCE -> StorageStrategy.builder()
                .primaryStorage(StorageType.MONGODB)
                .secondaryStorage(StorageType.REDIS)
                .enableRealTime(true)
                .enableMetrics(true)
                .build();

            case BUSINESS -> StorageStrategy.builder()
                .primaryStorage(StorageType.POSTGRESQL)
                .secondaryStorage(StorageType.MONGODB)
                .enableRealTime(false)
                .build();

            case ERROR -> StorageStrategy.builder()
                .primaryStorage(StorageType.POSTGRESQL)
                .secondaryStorage(StorageType.ELASTICSEARCH)
                .enableRealTime(true)
                .enableAlert(true)
                .build();
        };
    }

    private boolean isHighRisk(LogEvent logEvent) {
        return logEvent.getRiskLevel() == LogEvent.RiskLevel.HIGH ||
               logEvent.getRiskLevel() == LogEvent.RiskLevel.CRITICAL ||
               isSecuritySensitiveOperation(logEvent);
    }

    private boolean isSecuritySensitiveOperation(LogEvent logEvent) {
        Set<String> sensitiveOps = Set.of(
            "USER_LOGIN", "PASSWORD_CHANGE", "PERMISSION_CHANGE",
            "DEVICE_CONTROL", "DATA_EXPORT", "ADMIN_ACCESS"
        );
        return sensitiveOps.contains(logEvent.getOperationType());
    }
}
```

## ğŸ“Š æ—¥å¿—æµç¨‹å›¾

### æ³¨è§£å¼æ—¥å¿—æµç¨‹

```mermaid
sequenceDiagram
    participant Controller as ä¸šåŠ¡æ§åˆ¶å™¨
    participant Aspect as LogAspectåˆ‡é¢
    participant Client as LogClient
    participant Storage as Storage Service
    participant DB as æ•°æ®åº“

    Controller->>Controller: @LogOperationæ–¹æ³•è°ƒç”¨
    Note over Controller: æ–¹æ³•å¼€å§‹æ‰§è¡Œ

    Aspect->>Aspect: å‰ç½®å¤„ç†
    Note over Aspect: è®°å½•å¼€å§‹æ—¶é—´ã€æ„å»ºLogEvent

    Controller->>Controller: æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    Note over Controller: å®é™…ä¸šåŠ¡å¤„ç†

    Controller-->>Aspect: æ–¹æ³•æ‰§è¡Œå®Œæˆ
    Note over Aspect: è®¡ç®—æ‰§è¡Œæ—¶é—´ã€è¡¥å……ç»“æœä¿¡æ¯

    Aspect->>Client: æ„å»ºå®Œæ•´LogEvent
    Client->>Client: å¼‚æ­¥å‘é€æ—¥å¿—
    Note over Client: ä½¿ç”¨CompletableFutureå¼‚æ­¥å¤„ç†

    Client->>Storage: POST /api/v1/logs/{type}
    Note over Client,Storage: HTTPè¯·æ±‚ï¼Œæºå¸¦TraceID

    Storage->>Storage: éªŒè¯å’Œå¤„ç†
    Storage->>DB: å­˜å‚¨æ—¥å¿—æ•°æ®

    Storage-->>Client: å¼‚æ­¥å“åº”
    Client-->>Aspect: æ—¥å¿—å‘é€å®Œæˆ
    Aspect-->>Controller: è¿”å›ä¸šåŠ¡ç»“æœ
```

### ç¼–ç¨‹å¼æ—¥å¿—æµç¨‹

```mermaid
sequenceDiagram
    participant Service as ä¸šåŠ¡æœåŠ¡
    participant Client as LogClient
    participant Storage as Storage Service
    participant Cache as Redisç¼“å­˜
    participant DB as æ•°æ®åº“

    Service->>Client: logOperation(...)
    Note over Service,Client: ä¸»åŠ¨è°ƒç”¨æ—¥å¿—è®°å½•

    Client->>Client: æ„å»ºLogEvent
    Note over Client: è®¾ç½®åŸºç¡€ä¿¡æ¯ã€è®¡ç®—è€—æ—¶

    Client->>Storage: å¼‚æ­¥å‘é€æ—¥å¿—
    Note over Client,Storage: CompletableFutureå¼‚æ­¥å¤„ç†

    Storage->>Storage: æ•°æ®éªŒè¯
    Storage->>Storage: ç¡®å®šå­˜å‚¨ç­–ç•¥

    par ä¸»å­˜å‚¨
        Storage->>DB: æŒä¹…åŒ–å­˜å‚¨
    and ç¼“å­˜å­˜å‚¨
        Storage->>Cache: å®æ—¶ç»Ÿè®¡æ›´æ–°
    and å®æ—¶å¤„ç†
        Storage->>Storage: é£é™©æ£€æµ‹å’Œå‘Šè­¦
    end

    Storage-->>Client: å¼‚æ­¥å“åº”æˆåŠŸ
    Client-->>Service: æ—¥å¿—è®°å½•å®Œæˆ
```

### æ‰¹é‡æ—¥å¿—å¤„ç†æµç¨‹

```mermaid
graph TD
    A[æ‰¹é‡æ—¥å¿—è¯·æ±‚] --> B[æ•°æ®éªŒè¯]
    B --> C[æŒ‰ç±»å‹åˆ†ç»„]
    C --> D[å¹¶è¡Œå¤„ç†]

    D --> E[æ“ä½œæ—¥å¿—æ‰¹æ¬¡]
    D --> F[å®‰å…¨æ—¥å¿—æ‰¹æ¬¡]
    D --> G[æ€§èƒ½æ—¥å¿—æ‰¹æ¬¡]

    E --> H[PostgreSQLå­˜å‚¨]
    F --> I[PostgreSQL + ESå­˜å‚¨]
    G --> J[MongoDB + Rediså­˜å‚¨]

    H --> K[æ‰¹æ¬¡ç»“æœ]
    I --> K
    J --> K

    K --> L[èšåˆç»“æœ]
    L --> M[è¿”å›å¤„ç†æŠ¥å‘Š]
```

## ğŸ” æ—¥å¿—å®‰å…¨æœºåˆ¶

### æ•æ„Ÿæ•°æ®ä¿æŠ¤

```java
/**
 * æ•æ„Ÿæ•°æ®è„±æ•å¤„ç†å™¨
 */
@Component
public class SensitiveDataMasker {

    // æ•æ„Ÿå­—æ®µé…ç½®
    private static final Map<String, MaskingRule> MASKING_RULES = Map.of(
        "password", MaskingRule.FULL_MASK,
        "phone", MaskingRule.MIDDLE_MASK,
        "email", MaskingRule.MIDDLE_MASK,
        "idCard", MaskingRule.MIDDLE_MASK,
        "bankCard", MaskingRule.PARTIAL_MASK,
        "address", MaskingRule.PARTIAL_MASK
    );

    /**
     * è„±æ•å¤„ç†æ—¥å¿—æ•°æ®
     */
    public LogEvent maskSensitiveData(LogEvent logEvent) {
        // è„±æ•æ“ä½œæè¿°
        if (logEvent.getDescription() != null) {
            logEvent.setDescription(maskString(logEvent.getDescription()));
        }

        // è„±æ•æ‰©å±•æ•°æ®
        if (logEvent.getExtraData() != null) {
            Map<String, Object> maskedData = new HashMap<>();
            logEvent.getExtraData().forEach((key, value) -> {
                if (MASKING_RULES.containsKey(key.toLowerCase())) {
                    maskedData.put(key, maskValue(value, MASKING_RULES.get(key.toLowerCase())));
                } else {
                    maskedData.put(key, value);
                }
            });
            logEvent.setExtraData(maskedData);
        }

        return logEvent;
    }

    private String maskValue(Object value, MaskingRule rule) {
        if (value == null) return null;
        String str = value.toString();

        return switch (rule) {
            case FULL_MASK -> "*".repeat(str.length());
            case MIDDLE_MASK -> maskMiddle(str);
            case PARTIAL_MASK -> maskPartial(str);
            default -> str;
        };
    }

    private String maskMiddle(String str) {
        if (str.length() <= 6) return str.charAt(0) + "*".repeat(str.length() - 2) + str.charAt(str.length() - 1);

        int prefixLen = 3;
        int suffixLen = 3;
        return str.substring(0, prefixLen) + "*".repeat(str.length() - prefixLen - suffixLen) + str.substring(str.length() - suffixLen);
    }

    private String maskPartial(String str) {
        if (str.length() <= 4) return "*".repeat(str.length());
        return str.substring(0, 2) + "*".repeat(str.length() - 4) + str.substring(str.length() - 2);
    }

    enum MaskingRule {
        FULL_MASK, MIDDLE_MASK, PARTIAL_MASK, NO_MASK
    }
}
```

### æ—¥å¿—è®¿é—®æƒé™æ§åˆ¶

```java
/**
 * æ—¥å¿—è®¿é—®æƒé™æ§åˆ¶
 */
@Component
public class LogAccessController {

    /**
     * æ£€æŸ¥æ—¥å¿—æŸ¥è¯¢æƒé™
     */
    public boolean checkQueryPermission(String serviceId, String familyId, LogQueryRequest request) {
        // 1. æœåŠ¡æƒé™æ£€æŸ¥
        if (!hasServicePermission(serviceId, request.getLogType())) {
            return false;
        }

        // 2. å®¶åº­æ•°æ®éš”ç¦»æ£€æŸ¥
        if (!familyId.equals(request.getFamilyId())) {
            return false;
        }

        // 3. æ—¶é—´èŒƒå›´é™åˆ¶æ£€æŸ¥
        if (!isValidTimeRange(request.getStartTime(), request.getEndTime())) {
            return false;
        }

        // 4. æ•æ„Ÿæ—¥å¿—è®¿é—®æ£€æŸ¥
        if (isSensitiveLog(request.getLogType()) && !hasAdminPermission(serviceId)) {
            return false;
        }

        return true;
    }

    private boolean hasServicePermission(String serviceId, LogEvent.LogType logType) {
        Map<String, Set<LogEvent.LogType>> permissions = Map.of(
            "account-service", Set.of(LogEvent.LogType.OPERATION, LogEvent.LogType.SECURITY),
            "message-service", Set.of(LogEvent.LogType.OPERATION, LogEvent.LogType.BUSINESS),
            "ai-service", Set.of(LogEvent.LogType.PERFORMANCE, LogEvent.LogType.BUSINESS),
            "admin-service", Set.of(LogEvent.LogType.values()) // ç®¡ç†æœåŠ¡å¯è®¿é—®æ‰€æœ‰æ—¥å¿—
        );

        return permissions.getOrDefault(serviceId, Set.of()).contains(logType);
    }

    private boolean isSensitiveLog(LogEvent.LogType logType) {
        return logType == LogEvent.LogType.SECURITY || logType == LogEvent.LogType.ERROR;
    }
}
```

## ğŸš€ æ—¥å¿—ä½¿ç”¨æŒ‡å—

### 1. æ³¨è§£å¼æ—¥å¿—ä½¿ç”¨

#### åŸºç¡€æ“ä½œæ—¥å¿—
```java
@RestController
public class UserController {

    @LogOperation(
        operationType = "USER_LOGIN",
        description = "ç”¨æˆ·ç™»å½•æ“ä½œ",
        recordExecutionTime = true
    )
    @PostMapping("/login")
    public LoginResult login(@RequestBody LoginRequest request) {
        // ä¸šåŠ¡é€»è¾‘è‡ªåŠ¨è®°å½•æ“ä½œæ—¥å¿—
        return userService.login(request);
    }

    @LogOperation(
        operationType = "USER_PROFILE_UPDATE",
        description = "æ›´æ–°ç”¨æˆ·èµ„æ–™",
        logType = LogEvent.LogType.BUSINESS,
        riskLevel = LogEvent.RiskLevel.LOW
    )
    @PutMapping("/profile")
    public void updateProfile(@RequestBody UpdateProfileRequest request) {
        userService.updateProfile(request);
    }
}
```

#### å®‰å…¨æ•æ„Ÿæ“ä½œæ—¥å¿—
```java
@RestController
public class SecurityController {

    @LogOperation(
        operationType = "PASSWORD_CHANGE",
        description = "ç”¨æˆ·ä¿®æ”¹å¯†ç ",
        logType = LogEvent.LogType.SECURITY,
        riskLevel = LogEvent.RiskLevel.MEDIUM,
        recordExecutionTime = true
    )
    @PostMapping("/change-password")
    public void changePassword(@RequestBody ChangePasswordRequest request) {
        securityService.changePassword(request);
    }

    @LogOperation(
        operationType = "ADMIN_ACCESS",
        description = "ç®¡ç†å‘˜æƒé™è®¿é—®",
        logType = LogEvent.LogType.SECURITY,
        riskLevel = LogEvent.RiskLevel.HIGH
    )
    @GetMapping("/admin/users")
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
}
```

### 2. ç¼–ç¨‹å¼æ—¥å¿—ä½¿ç”¨

#### æ€§èƒ½ç›‘æ§æ—¥å¿—
```java
@Service
public class DeviceService {

    @Autowired
    private LogClient logClient;

    public void controlDevice(String familyId, String userId, String deviceId, String action) {
        long startTime = System.currentTimeMillis();
        String traceId = TraceIdGenerator.generate();

        try {
            // ä¸šåŠ¡é€»è¾‘
            deviceManager.sendCommand(deviceId, action);

            // è®°å½•æˆåŠŸçš„æ€§èƒ½æ—¥å¿—
            logClient.logPerformance(
                familyId, userId, "DEVICE_CONTROL",
                "è®¾å¤‡æ§åˆ¶: " + deviceId + " -> " + action,
                startTime,
                Map.of(
                    "deviceId", deviceId,
                    "action", action,
                    "result", "success"
                )
            );

        } catch (Exception e) {
            // è®°å½•é”™è¯¯æ—¥å¿—
            logClient.logError(
                familyId, userId, "DEVICE_CONTROL",
                "è®¾å¤‡æ§åˆ¶å¤±è´¥: " + e.getMessage(),
                e,
                Map.of(
                    "deviceId", deviceId,
                    "action", action,
                    "errorType", e.getClass().getSimpleName()
                )
            );
            throw e;
        }
    }
}
```

#### ä¸šåŠ¡æµç¨‹æ—¥å¿—
```java
@Service
public class OrderService {

    @Autowired
    private LogClient logClient;

    @Transactional
    public Order createOrder(CreateOrderRequest request) {
        String familyId = request.getFamilyId();
        String userId = request.getUserId();

        // è®°å½•è®¢å•åˆ›å»ºå¼€å§‹
        logClient.logBusiness(familyId, userId, "ORDER_CREATE_START",
            "å¼€å§‹åˆ›å»ºè®¢å•", Map.of("productCount", request.getItems().size()));

        try {
            // åˆ›å»ºè®¢å•
            Order order = new Order();
            // ... ä¸šåŠ¡é€»è¾‘

            // è®°å½•è®¢å•åˆ›å»ºæˆåŠŸ
            logClient.logBusiness(familyId, userId, "ORDER_CREATE_SUCCESS",
                "è®¢å•åˆ›å»ºæˆåŠŸ", Map.of(
                    "orderId", order.getId(),
                    "totalAmount", order.getTotalAmount(),
                    "itemCount", order.getItems().size()
                ));

            return order;

        } catch (Exception e) {
            // è®°å½•è®¢å•åˆ›å»ºå¤±è´¥
            logClient.logError(familyId, userId, "ORDER_CREATE_FAILED",
                "è®¢å•åˆ›å»ºå¤±è´¥: " + e.getMessage(), e);
            throw e;
        }
    }
}
```

### 3. æ‰¹é‡æ—¥å¿—å‘é€

```java
@Service
public class BatchLogService {

    @Autowired
    private LogClient logClient;

    /**
     * æ‰¹é‡è®°å½•è®¾å¤‡çŠ¶æ€æ—¥å¿—
     */
    public void batchLogDeviceStates(String familyId, List<DeviceState> states) {
        List<LogEvent> logEvents = states.stream()
            .map(state -> LogEvent.builder()
                .familyId(familyId)
                .logType(LogEvent.LogType.PERFORMANCE)
                .operationType("DEVICE_STATE_UPDATE")
                .description("è®¾å¤‡çŠ¶æ€æ›´æ–°: " + state.getDeviceId())
                .timestamp(System.currentTimeMillis())
                .extraData(Map.of(
                    "deviceId", state.getDeviceId(),
                    "status", state.getStatus(),
                    "temperature", state.getTemperature(),
                    "humidity", state.getHumidity()
                ))
                .build())
            .collect(Collectors.toList());

        // æ‰¹é‡å‘é€æ—¥å¿—
        logClient.sendBatchLogs(logEvents)
            .thenAccept(result -> {
                log.info("æ‰¹é‡æ—¥å¿—å‘é€å®Œæˆ: æˆåŠŸ={}, å¤±è´¥={}",
                        result.getSuccessCount(), result.getFailureCount());
            })
            .exceptionally(e -> {
                log.error("æ‰¹é‡æ—¥å¿—å‘é€å¤±è´¥", e);
                return null;
            });
    }
}
```

## ğŸ“ˆ æ—¥å¿—ç›‘æ§å’Œåˆ†æ

### å®æ—¶ç›‘æ§æŒ‡æ ‡

```java
/**
 * æ—¥å¿—å®æ—¶ç›‘æ§
 */
@Component
public class LogRealTimeMonitor {

    private final MeterRegistry registry;
    private final RedisTemplate<String, Object> redisTemplate;

    /**
     * æ›´æ–°å®æ—¶æŒ‡æ ‡
     */
    public void updateMetrics(LogEvent logEvent) {
        String familyId = logEvent.getFamilyId();
        String logType = logEvent.getLogType().name();

        // 1. è®¡æ•°å™¨æŒ‡æ ‡
        registry.counter("logs.count",
                        Tags.of("family", familyId, "type", logType))
                .increment();

        // 2. å“åº”æ—¶é—´æŒ‡æ ‡
        if (logEvent.getExecutionTime() != null) {
            registry.timer("logs.execution.time",
                          Tags.of("family", familyId, "operation", logEvent.getOperationType()))
                    .record(logEvent.getExecutionTime(), TimeUnit.MILLISECONDS);
        }

        // 3. é”™è¯¯ç‡æŒ‡æ ‡
        if (logEvent.getLogType() == LogEvent.LogType.ERROR) {
            registry.counter("logs.error.count",
                            Tags.of("family", familyId, "service", logEvent.getServiceId()))
                    .increment();
        }

        // 4. å®æ—¶ç»Ÿè®¡æ›´æ–°
        updateRealTimeStats(logEvent);
    }

    private void updateRealTimeStats(LogEvent logEvent) {
        String familyId = logEvent.getFamilyId();
        String today = LocalDate.now().toString();

        // æ¯æ—¥æ—¥å¿—ç»Ÿè®¡
        String dailyKey = "logs:daily:" + familyId + ":" + today;
        redisTemplate.opsForHash().increment(dailyKey, logEvent.getLogType().name(), 1);
        redisTemplate.expire(dailyKey, 7, TimeUnit.DAYS);

        // å®æ—¶é”™è¯¯ç»Ÿè®¡
        if (logEvent.getLogType() == LogEvent.LogType.ERROR) {
            String errorKey = "logs:errors:" + familyId + ":recent";
            redisTemplate.opsForList().leftPush(errorKey, logEvent);
            redisTemplate.opsForList().trim(errorKey, 0, 99); // ä¿ç•™æœ€è¿‘100æ¡é”™è¯¯
            redisTemplate.expire(errorKey, 1, TimeUnit.HOURS);
        }

        // æ€§èƒ½ç»Ÿè®¡
        if (logEvent.getExecutionTime() != null) {
            String perfKey = "logs:performance:" + familyId + ":" + logEvent.getOperationType();
            redisTemplate.opsForList().leftPush(perfKey, logEvent.getExecutionTime());
            redisTemplate.opsForList().trim(perfKey, 0, 999); // ä¿ç•™æœ€è¿‘1000æ¬¡è®°å½•
            redisTemplate.expire(perfKey, 1, TimeUnit.HOURS);
        }
    }
}
```

### æ—¥å¿—æŸ¥è¯¢å’Œåˆ†æAPI

```java
/**
 * æ—¥å¿—æŸ¥è¯¢æ§åˆ¶å™¨
 */
@RestController
@RequestMapping("/api/v1/logs")
public class LogQueryController {

    private final LogQueryService logQueryService;
    private final LogAnalysisService logAnalysisService;

    /**
     * æŸ¥è¯¢æ“ä½œæ—¥å¿—
     */
    @GetMapping("/operations")
    public ApiResponse<PageResult<OperationLog>> queryOperationLogs(
            @RequestHeader("X-Family-ID") String familyId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String operationType,
            @RequestParam(required = false) String userId,
            @RequestParam(required = false) Long startTime,
            @RequestParam(required = false) Long endTime) {

        LogQueryRequest request = LogQueryRequest.builder()
            .familyId(familyId)
            .logType(LogEvent.LogType.OPERATION)
            .operationType(operationType)
            .userId(userId)
            .startTime(startTime)
            .endTime(endTime)
            .page(page)
            .size(size)
            .build();

        PageResult<OperationLog> result = logQueryService.queryOperationLogs(request);
        return ApiResponse.success(result);
    }

    /**
     * å®‰å…¨äº‹ä»¶ç»Ÿè®¡
     */
    @GetMapping("/security/stats")
    public ApiResponse<SecurityStats> getSecurityStats(
            @RequestHeader("X-Family-ID") String familyId,
            @RequestParam(defaultValue = "7") int days) {

        SecurityStats stats = logAnalysisService.getSecurityStats(familyId, days);
        return ApiResponse.success(stats);
    }

    /**
     * æ€§èƒ½æŒ‡æ ‡ç»Ÿè®¡
     */
    @GetMapping("/performance/stats")
    public ApiResponse<PerformanceStats> getPerformanceStats(
            @RequestHeader("X-Family-ID") String familyId,
            @RequestParam(required = false) String operationType,
            @RequestParam(defaultValue = "24") int hours) {

        PerformanceStats stats = logAnalysisService.getPerformanceStats(
            familyId, operationType, hours);
        return ApiResponse.success(stats);
    }

    /**
     * å®æ—¶ç›‘æ§æ•°æ®
     */
    @GetMapping("/metrics/realtime")
    public ApiResponse<RealTimeMetrics> getRealTimeMetrics(
            @RequestHeader("X-Family-ID") String familyId) {

        RealTimeMetrics metrics = logAnalysisService.getRealTimeMetrics(familyId);
        return ApiResponse.success(metrics);
    }
}
```

## ğŸ” æ—¥å¿—å‘Šè­¦å’Œé€šçŸ¥

### å‘Šè­¦è§„åˆ™é…ç½®

```java
/**
 * æ—¥å¿—å‘Šè­¦ç®¡ç†å™¨
 */
@Component
public class LogAlertManager {

    private final AlertRuleEngine ruleEngine;
    private final NotificationService notificationService;

    /**
     * å¤„ç†æ—¥å¿—å‘Šè­¦
     */
    public void processAlert(LogEvent logEvent) {
        // 1. åŒ¹é…å‘Šè­¦è§„åˆ™
        List<AlertRule> matchedRules = ruleEngine.match(logEvent);

        for (AlertRule rule : matchedRules) {
            // 2. æ£€æŸ¥å‘Šè­¦é¢‘ç‡é™åˆ¶
            if (!checkRateLimit(rule, logEvent)) {
                continue;
            }

            // 3. ç”Ÿæˆå‘Šè­¦äº‹ä»¶
            AlertEvent alertEvent = createAlertEvent(rule, logEvent);

            // 4. å‘é€é€šçŸ¥
            sendNotification(alertEvent);

            // 5. è®°å½•å‘Šè­¦å†å²
            recordAlertHistory(alertEvent);
        }
    }

    private AlertEvent createAlertEvent(AlertRule rule, LogEvent logEvent) {
        return AlertEvent.builder()
            .ruleId(rule.getId())
            .ruleName(rule.getName())
            .severity(rule.getSeverity())
            .familyId(logEvent.getFamilyId())
            .serviceId(logEvent.getServiceId())
            .description(rule.getDescription())
            .logEvent(logEvent)
            .timestamp(System.currentTimeMillis())
            .build();
    }

    private void sendNotification(AlertEvent alertEvent) {
        // æ ¹æ®å‘Šè­¦çº§åˆ«é€‰æ‹©é€šçŸ¥æ–¹å¼
        switch (alertEvent.getSeverity()) {
            case CRITICAL -> {
                // ä¸¥é‡å‘Šè­¦ï¼šçŸ­ä¿¡ + é‚®ä»¶ + é’‰é’‰
                notificationService.sendSms(alertEvent);
                notificationService.sendEmail(alertEvent);
                notificationService.sendDingTalk(alertEvent);
            }
            case HIGH -> {
                // é«˜çº§å‘Šè­¦ï¼šé‚®ä»¶ + é’‰é’‰
                notificationService.sendEmail(alertEvent);
                notificationService.sendDingTalk(alertEvent);
            }
            case MEDIUM -> {
                // ä¸­çº§å‘Šè­¦ï¼šé’‰é’‰
                notificationService.sendDingTalk(alertEvent);
            }
            case LOW -> {
                // ä½çº§å‘Šè­¦ï¼šä»…è®°å½•
                log.info("ä½çº§å‘Šè­¦: {}", alertEvent.getDescription());
            }
        }
    }
}
```

### é¢„å®šä¹‰å‘Šè­¦è§„åˆ™

```yaml
# æ—¥å¿—å‘Šè­¦è§„åˆ™é…ç½®
log:
  alerts:
    rules:
      # ç™»å½•å¤±è´¥å‘Šè­¦
      - id: "login_failure_rate"
        name: "ç™»å½•å¤±è´¥ç‡è¿‡é«˜"
        condition: "logType == 'SECURITY' && operationType == 'USER_LOGIN' && errorMessage != null"
        threshold:
          count: 5
          timeWindow: "5m"
        severity: "HIGH"
        description: "5åˆ†é’Ÿå†…ç™»å½•å¤±è´¥è¶…è¿‡5æ¬¡"

      # æ€§èƒ½è¶…æ—¶å‘Šè­¦
      - id: "performance_timeout"
        name: "æ“ä½œå“åº”æ—¶é—´è¿‡é•¿"
        condition: "executionTime > 5000"
        threshold:
          count: 3
          timeWindow: "1m"
        severity: "MEDIUM"
        description: "æ“ä½œå“åº”æ—¶é—´è¶…è¿‡5ç§’"

      # é”™è¯¯ç‡å‘Šè­¦
      - id: "error_rate_spike"
        name: "é”™è¯¯ç‡æ¿€å¢"
        condition: "logType == 'ERROR'"
        threshold:
          rate: 10
          timeWindow: "5m"
        severity: "CRITICAL"
        description: "5åˆ†é’Ÿå†…é”™è¯¯ç‡è¶…è¿‡10%"

      # å¼‚å¸¸æ“ä½œå‘Šè­¦
      - id: "suspicious_operation"
        name: "å¯ç–‘æ“ä½œæ£€æµ‹"
        condition: "riskLevel == 'HIGH' || riskLevel == 'CRITICAL'"
        threshold:
          count: 1
          timeWindow: "1m"
        severity: "HIGH"
        description: "æ£€æµ‹åˆ°é«˜é£é™©æ“ä½œ"
```

## ğŸ“‹ æ—¥å¿—æœ€ä½³å®è·µ

### 1. æ—¥å¿—è®°å½•å»ºè®®
- **å…³é”®æ“ä½œå¿…è®°**: ç”¨æˆ·ç™»å½•ã€æƒé™å˜æ›´ã€è®¾å¤‡æ§åˆ¶ç­‰å…³é”®æ“ä½œ
- **æ€§èƒ½ç›‘æ§**: è®°å½•å…³é”®æ¥å£çš„æ‰§è¡Œæ—¶é—´
- **é”™è¯¯è¯¦æƒ…**: è®°å½•å®Œæ•´çš„é”™è¯¯ä¿¡æ¯å’Œå †æ ˆä¿¡æ¯
- **ä¸šåŠ¡æµç¨‹**: è®°å½•é‡è¦ä¸šåŠ¡æµç¨‹çš„å…³é”®èŠ‚ç‚¹

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®
- **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨å¼‚æ­¥æ–¹å¼å‘é€æ—¥å¿—ï¼Œé¿å…å½±å“ä¸šåŠ¡æ€§èƒ½
- **æ‰¹é‡å‘é€**: å¯¹äºå¤§é‡æ—¥å¿—ï¼Œä½¿ç”¨æ‰¹é‡å‘é€æé«˜æ•ˆç‡
- **åˆç†é‡‡æ ·**: å¯¹äºé«˜é¢‘æ“ä½œï¼Œå¯ä»¥ä½¿ç”¨é‡‡æ ·æ–¹å¼å‡å°‘æ—¥å¿—é‡
- **å­˜å‚¨ä¼˜åŒ–**: æ ¹æ®æ—¥å¿—ç±»å‹é€‰æ‹©åˆé€‚çš„å­˜å‚¨æ–¹å¼

### 3. å®‰å…¨é˜²æŠ¤å»ºè®®
- **æ•æ„Ÿæ•°æ®è„±æ•**: å¯¹å¯†ç ã€æ‰‹æœºå·ç­‰æ•æ„Ÿä¿¡æ¯è¿›è¡Œè„±æ•
- **è®¿é—®æƒé™æ§åˆ¶**: ä¸¥æ ¼æ§åˆ¶æ—¥å¿—æŸ¥è¯¢å’Œåˆ†ææƒé™
- **æ•°æ®éš”ç¦»**: ç¡®ä¿ä¸åŒå®¶åº­çš„æ—¥å¿—æ•°æ®ä¸¥æ ¼éš”ç¦»
- **ä¼ è¾“åŠ å¯†**: æ—¥å¿—ä¼ è¾“è¿‡ç¨‹ä¸­ä½¿ç”¨HTTPSåŠ å¯†

### 4. è¿ç»´ç®¡ç†å»ºè®®
- **å®šæœŸæ¸…ç†**: åˆ¶å®šæ—¥å¿—ä¿ç•™ç­–ç•¥ï¼Œå®šæœŸæ¸…ç†è¿‡æœŸæ—¥å¿—
- **ç›‘æ§å‘Šè­¦**: å»ºç«‹å®Œå–„çš„æ—¥å¿—ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
- **æ€§èƒ½ç›‘æ§**: ç›‘æ§æ—¥å¿—ç³»ç»Ÿæœ¬èº«çš„æ€§èƒ½æŒ‡æ ‡
- **å¤‡ä»½ç­–ç•¥**: å¯¹é‡è¦æ—¥å¿—è¿›è¡Œå®šæœŸå¤‡ä»½

---

**ç»Ÿä¸€æ—¥å¿—ç³»ç»Ÿ** - ä¸ºHavenButlerå¹³å°æä¾›å…¨é¢çš„æ—¥å¿—æ”¶é›†ã€åˆ†æå’Œç›‘æ§æœåŠ¡ ğŸ“