# æ•°æ®åº“è®¿é—®ä»£ç†ç³»ç»Ÿè¯¦è§£

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

æ•°æ®åº“è®¿é—®ä»£ç†ç³»ç»Ÿæ˜¯ Storage Service åŸºäº **Nettyæ¡†æ¶** å®ç°çš„ **TCPåè®®ä»£ç†æœåŠ¡**ï¼Œä¸ºå¾®æœåŠ¡æä¾›é€æ˜çš„æ•°æ®åº“è®¿é—®ä»£ç†ã€‚æ”¯æŒ PostgreSQLã€MongoDBã€Redis ä¸‰ç§æ•°æ®åº“çš„**åŸç”Ÿåè®®ä»£ç†**ï¼Œå®ç°è¿æ¥æ± ç®¡ç†ã€å®‰å…¨æ§åˆ¶ã€æ“ä½œå®¡è®¡å’Œæ€§èƒ½ä¼˜åŒ–ã€‚

### ğŸ”— ä»£ç†æ¨¡å¼è¯´æ˜
- **TCPåè®®ä»£ç†**ï¼šå¾®æœåŠ¡ä½¿ç”¨æ ‡å‡†æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²ï¼Œè¿æ¥åˆ°ä»£ç†ç«¯å£
- **åè®®é€æ˜**ï¼šå®Œå…¨å…¼å®¹åŸç”Ÿæ•°æ®åº“åè®®ï¼Œæ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 
- **ç«¯å£æ˜ å°„**ï¼šPostgreSQL(5433)ã€MongoDB(27018)ã€Redis(6380)

## ğŸ—ï¸ ä»£ç†æ¶æ„è®¾è®¡

### TCPä»£ç†æ¶æ„å›¾

```mermaid
graph TB
    subgraph "å¾®æœåŠ¡å±‚"
        A[Account Service<br/>jdbc:postgresql://storage:5433/db]
        B[Message Service<br/>mongodb://storage:27018/db]
        C[AI Service<br/>redis://storage:6380]
        D[NLP Service<br/>jdbc:postgresql://storage:5433/db]
    end

    subgraph "Storage Service - Netty TCPä»£ç†"
        F[ProxyServerBootstrap<br/>NettyæœåŠ¡å¯åŠ¨å™¨]
        G[PostgresProxyHandler<br/>ç«¯å£5433]
        H[MongoProxyHandler<br/>ç«¯å£27018]
        I[RedisProxyHandler<br/>ç«¯å£6380]
        J[PostgresConnectionPool<br/>è¿æ¥æ± ç®¡ç†]
        K[åè®®è§£æä¸å®‰å…¨æ£€æŸ¥]
        L[æ“ä½œæ—¥å¿—è®°å½•]
    end

    subgraph "çœŸå®æ•°æ®åº“é›†ç¾¤"
        M[PostgreSQL<br/>ç«¯å£5432]
        N[MongoDB<br/>ç«¯å£27017]
        O[Redis<br/>ç«¯å£6379]
    end

    A -.->|TCPè¿æ¥| G
    B -.->|TCPè¿æ¥| H
    C -.->|TCPè¿æ¥| I
    D -.->|TCPè¿æ¥| G

    G --> J
    G --> K
    G --> L
    H --> K
    H --> L
    I --> K
    I --> L

    G -.->|ä»£ç†è½¬å‘| M
    H -.->|ä»£ç†è½¬å‘| N
    I -.->|ä»£ç†è½¬å‘| O
```

### æ ¸å¿ƒç»„ä»¶è¯´æ˜

#### 1. ProxyServerBootstrapï¼ˆä»£ç†æœåŠ¡å¯åŠ¨å™¨ï¼‰
- **å®ç°æ–¹å¼**: Netty ServerBootstrap
- **èŒè´£**: å¯åŠ¨ä¸‰ä¸ªTCPä»£ç†æœåŠ¡å™¨
- **ç«¯å£ç®¡ç†**: ç›‘å¬ä¸åŒç«¯å£æä¾›ä»£ç†æœåŠ¡
- **çº¿ç¨‹æ¨¡å‹**: Bossçº¿ç¨‹ç»„ + Workerçº¿ç¨‹ç»„

#### 2. PostgresProxyHandlerï¼ˆPostgreSQLä»£ç†å¤„ç†å™¨ï¼‰
- **åè®®æ”¯æŒ**: PostgreSQL Wire Protocol
- **åŠŸèƒ½ç‰¹æ€§**:
  - åè®®æ¶ˆæ¯è§£æï¼ˆQueryã€Parseã€Bindã€Executeç­‰ï¼‰
  - SQLæ³¨å…¥é˜²æŠ¤å’Œå±é™©æ“ä½œæ‹¦æˆª
  - è¿æ¥çŠ¶æ€ç®¡ç†å’Œäº‹åŠ¡ä¸Šä¸‹æ–‡
  - æ“ä½œæ—¥å¿—è®°å½•å’Œå®‰å…¨å®¡è®¡

#### 3. PostgresConnectionPoolï¼ˆè¿æ¥æ± ç®¡ç†å™¨ï¼‰
- **å®ç°æŠ€æœ¯**: Netty Bootstrap + BlockingQueue
- **è¿æ¥ç®¡ç†**: é¢„åˆ›å»ºè¿æ¥ã€åŠ¨æ€æ‰©å±•ã€è¿æ¥å›æ”¶
- **é…ç½®å‚æ•°**: æœ€å¤§è¿æ¥æ•°ã€æœ€å°ç©ºé—²æ•°ã€è¿æ¥è¶…æ—¶
- **å¥åº·ç›‘æ§**: è¿æ¥å¯ç”¨æ€§æ£€æŸ¥ã€è¿æ¥æ± çŠ¶æ€ç»Ÿè®¡

#### 4. åè®®å¤„ç†ç‰¹æ€§
- **é€æ˜ä»£ç†**: å®Œå…¨å…¼å®¹åŸç”Ÿæ•°æ®åº“åè®®
- **åŒå‘è½¬å‘**: å®¢æˆ·ç«¯â†”ä»£ç†â†”åç«¯æ•°æ®åº“
- **çŠ¶æ€ç»´æŠ¤**: è¿æ¥æ˜ å°„ã€äº‹åŠ¡çŠ¶æ€ã€ä¼šè¯ä¿¡æ¯

## ğŸ”§ TCPä»£ç†æŠ€æœ¯å®ç°

### Nettyä»£ç†æœåŠ¡å™¨å¯åŠ¨

```java
/**
 * åŸºäºNettyçš„æ•°æ®åº“ä»£ç†æœåŠ¡å¯åŠ¨å™¨
 */
@Component
public class ProxyServerBootstrap {

    @Value("${proxy.postgresql.port:5433}")
    private int postgresPort;

    @Value("${proxy.mongodb.port:27018}")
    private int mongoPort;

    @Value("${proxy.redis.port:6380}")
    private int redisPort;

    // å¯åŠ¨PostgreSQLä»£ç†æœåŠ¡
    private void startPostgresProxy() {
        ServerBootstrap bootstrap = new ServerBootstrap();
        bootstrap.group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) {
                    ch.pipeline().addLast("postgres-handler", postgresHandler);
                }
            });

        // ç»‘å®šç«¯å£å¯åŠ¨æœåŠ¡
        ChannelFuture future = bootstrap.bind(postgresPort).sync();
        log.info("PostgreSQLä»£ç†æœåŠ¡å¯åŠ¨æˆåŠŸï¼Œç›‘å¬ç«¯å£: {}", postgresPort);
    }
}
```

### PostgreSQLåè®®ä»£ç†å¤„ç†

```java
/**
 * PostgreSQL Wire Protocol ä»£ç†å¤„ç†å™¨
 */
@ChannelHandler.Sharable
public class PostgresProxyHandler extends ChannelInboundHandlerAdapter {

    // å­˜å‚¨å®¢æˆ·ç«¯ä¸åç«¯è¿æ¥çš„æ˜ å°„
    private final Map<ChannelId, Channel> clientToBackendChannelMap;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf data = (ByteBuf) msg;

        // 1. è§£æPostgreSQLåè®®æ¶ˆæ¯
        parseAndLogPostgresMessage(ctx, data.duplicate(), clientIP);

        // 2. å®‰å…¨æ£€æŸ¥ï¼ˆSQLæ³¨å…¥é˜²æŠ¤ï¼‰
        if (isDangerousOperation(sqlContent)) {
            sendErrorResponse(ctx, "æ“ä½œè¢«ä»£ç†æ‹¦æˆª");
            return;
        }

        // 3. è½¬å‘åˆ°åç«¯æ•°æ®åº“
        Channel backendChannel = clientToBackendChannelMap.get(ctx.channel().id());
        backendChannel.writeAndFlush(data.retain());
    }
}
```

### è¿æ¥æ± ç®¡ç†å®ç°

```java
/**
 * PostgreSQLè¿æ¥æ± ç®¡ç†å™¨
 */
@Component
public class PostgresConnectionPool {

    @Value("${proxy.postgresql.backend.host:localhost}")
    private String backendHost;

    @Value("${proxy.postgresql.backend.port:5432}")
    private int backendPort;

    // è¿æ¥æ± é˜Ÿåˆ—
    private BlockingQueue<Channel> availableConnections;
    private final AtomicInteger activeConnections = new AtomicInteger(0);

    /**
     * è·å–å¯ç”¨è¿æ¥
     */
    public Channel getConnection() throws InterruptedException {
        Channel channel = availableConnections.poll(5, TimeUnit.SECONDS);

        if (channel == null || !channel.isActive()) {
            // åˆ›å»ºæ–°è¿æ¥
            channel = createConnection();
            if (channel != null) {
                totalConnections.incrementAndGet();
            }
        }

        if (channel != null && channel.isActive()) {
            activeConnections.incrementAndGet();
            return channel;
        }

        throw new RuntimeException("æ— æ³•è·å–PostgreSQLè¿æ¥");
    }

    /**
     * åˆ›å»ºåˆ°åç«¯PostgreSQLçš„è¿æ¥
     */
    private Channel createConnection() {
        ChannelFuture future = bootstrap.connect(backendHost, backendPort);
        return future.sync().channel();
    }
}
```

### PostgreSQLåè®®æ¶ˆæ¯è§£æ

```java
/**
 * PostgreSQLåè®®æ¶ˆæ¯è§£æå’Œå®‰å…¨æ£€æŸ¥
 */
private void parseAndLogPostgresMessage(ChannelHandlerContext ctx, ByteBuf data, String clientIP) {
    try {
        data.markReaderIndex();
        byte messageType = data.readByte();
        int messageLength = data.readInt();
        data.resetReaderIndex();

        String operation = "UNKNOWN";
        String content = "";

        // PostgreSQL Wire Protocol æ¶ˆæ¯ç±»å‹è§£æ
        switch (messageType) {
            case 'Q': // Simple Query
                operation = "QUERY";
                if (data.readableBytes() >= messageLength + 1) {
                    data.skipBytes(5); // è·³è¿‡ç±»å‹å’Œé•¿åº¦
                    byte[] sqlBytes = new byte[messageLength - 5];
                    data.readBytes(sqlBytes);
                    content = new String(sqlBytes, StandardCharsets.UTF_8);
                    if (content.endsWith("\0")) {
                        content = content.substring(0, content.length() - 1);
                    }
                }
                break;
            case 'P': // Parse
                operation = "PARSE";
                break;
            case 'B': // Bind
                operation = "BIND";
                break;
            case 'E': // Execute
                operation = "EXECUTE";
                break;
            case 'X': // Terminate
                operation = "TERMINATE";
                break;
        }

        // å±é™©æ“ä½œæ£€æŸ¥
        if (isDangerousOperation(content)) {
            log.warn("æ£€æµ‹åˆ°å±é™©æ“ä½œï¼Œæ‹’ç»æ‰§è¡Œ: {} - {}", clientIP, content);
            sendErrorResponse(ctx, "æ“ä½œè¢«ä»£ç†æ‹¦æˆªï¼š" + content);
            return;
        }

        // è®°å½•æ“ä½œæ—¥å¿—
        operationLogService.logOperation(/* æ—¥å¿—å‚æ•° */);

    } catch (Exception e) {
        log.warn("è§£æPostgreSQLæ¶ˆæ¯å¤±è´¥: {}", e.getMessage());
    }
}

/**
 * å±é™©æ“ä½œæ£€æŸ¥
 */
private boolean isDangerousOperation(String sql) {
    if (sql == null || sql.trim().isEmpty()) return false;

    String upperSQL = sql.trim().toUpperCase();
    String[] dangerousPatterns = {
        "DROP DATABASE", "DROP SCHEMA", "TRUNCATE TABLE",
        "DELETE FROM", "ALTER SYSTEM", "CREATE ROLE", "DROP ROLE"
    };

    for (String pattern : dangerousPatterns) {
        if (upperSQL.contains(pattern)) {
            return true;
        }
    }
    return false;
}
```

## ğŸ“Š TCPä»£ç†æµç¨‹å›¾

### PostgreSQL TCPä»£ç†è¿æ¥å»ºç«‹æµç¨‹

```mermaid
sequenceDiagram
    participant Client as å¾®æœåŠ¡å®¢æˆ·ç«¯
    participant Proxy as ProxyServerBootstrap
    participant Handler as PostgresProxyHandler
    participant Pool as ConnectionPool
    participant Backend as åç«¯PostgreSQL

    Client->>Proxy: TCPè¿æ¥åˆ°:5433
    Note over Client,Proxy: æ ‡å‡†PostgreSQLè¿æ¥å­—ç¬¦ä¸²

    Proxy->>Handler: channelActiveäº‹ä»¶
    Handler->>Pool: åˆ›å»ºåç«¯è¿æ¥
    Pool->>Backend: è¿æ¥åˆ°:5432
    Backend-->>Pool: è¿æ¥å»ºç«‹æˆåŠŸ
    Pool-->>Handler: è¿”å›åç«¯Channel
    Handler->>Handler: å»ºç«‹åŒå‘æ˜ å°„

    Note over Client,Backend: è¿æ¥å»ºç«‹å®Œæˆï¼Œå¼€å§‹è½¬å‘æ•°æ®

    Client->>Handler: PostgreSQLåè®®æ¶ˆæ¯
    Handler->>Handler: è§£ææ¶ˆæ¯ç±»å‹(Q/P/B/E/X)
    Handler->>Handler: å®‰å…¨æ£€æŸ¥å’Œæ—¥å¿—è®°å½•
    Handler->>Backend: è½¬å‘åˆ°åç«¯æ•°æ®åº“
    Backend-->>Handler: è¿”å›å“åº”æ•°æ®
    Handler-->>Client: è½¬å‘å“åº”ç»™å®¢æˆ·ç«¯
```

### PostgreSQLåè®®æ¶ˆæ¯å¤„ç†æµç¨‹

```mermaid
graph TD
    A[æ¥æ”¶TCPæ•°æ®] --> B[è¯»å–æ¶ˆæ¯ç±»å‹]
    B --> C{æ¶ˆæ¯ç±»å‹åˆ¤æ–­}

    C -->|'Q' Simple Query| D[è§£æSQLè¯­å¥]
    C -->|'P' Parse| E[è§£æé¢„å¤„ç†è¯­å¥]
    C -->|'B' Bind| F[ç»‘å®šå‚æ•°]
    C -->|'E' Execute| G[æ‰§è¡Œè¯­å¥]
    C -->|'X' Terminate| H[å…³é—­è¿æ¥]

    D --> I[å±é™©æ“ä½œæ£€æŸ¥]
    E --> I
    F --> J[è®°å½•æ“ä½œæ—¥å¿—]
    G --> J

    I -->|å®‰å…¨| J
    I -->|å±é™©| K[æ‹’ç»å¹¶è¿”å›é”™è¯¯]

    J --> L[è½¬å‘åˆ°åç«¯æ•°æ®åº“]
    K --> M[è®°å½•å®‰å…¨æ—¥å¿—]
    L --> N[è¿”å›å“åº”ç»™å®¢æˆ·ç«¯]
```

## ğŸ” ä»£ç†å®‰å…¨æœºåˆ¶

### å¤šå±‚å®‰å…¨é˜²æŠ¤

```mermaid
graph TD
    A[ä»£ç†è¯·æ±‚] --> B[Service-KeyéªŒè¯]
    B --> C[JWT TokenéªŒè¯]
    C --> D[FamilyIDæ•°æ®éš”ç¦»]
    D --> E[SQLæ³¨å…¥é˜²æŠ¤]
    E --> F[å±é™©æ“ä½œæ‹¦æˆª]
    F --> G[æƒé™çº§åˆ«æ£€æŸ¥]
    G --> H[å®¡è®¡æ—¥å¿—è®°å½•]
    H --> I[æ•°æ®åº“è®¿é—®]
```

### SQLå®‰å…¨é˜²æŠ¤å®ç°

```java
/**
 * SQLå®‰å…¨è§£æå™¨
 */
@Component
public class SQLSecurityParser {

    // å±é™©æ“ä½œå…³é”®è¯
    private static final Set<String> DANGEROUS_KEYWORDS = Set.of(
        "DROP", "TRUNCATE", "ALTER", "CREATE", "DELETE",
        "EXEC", "EXECUTE", "UNION", "SCRIPT", "DECLARE"
    );

    // å…è®¸çš„è¡¨å‰ç¼€
    private static final Set<String> ALLOWED_TABLE_PREFIXES = Set.of(
        "user_", "device_", "message_", "log_", "file_"
    );

    public ParsedSQL parseAndValidate(String sql, String familyId) {
        // 1. SQLæ³¨å…¥æ£€æµ‹
        if (containsSQLInjection(sql)) {
            throw new SecurityException("æ£€æµ‹åˆ°SQLæ³¨å…¥æ”»å‡»");
        }

        // 2. å±é™©æ“ä½œæ£€æµ‹
        if (containsDangerousOperation(sql)) {
            throw new SecurityException("ä¸å…è®¸æ‰§è¡Œå±é™©æ“ä½œ");
        }

        // 3. è¡¨è®¿é—®æƒé™æ£€æŸ¥
        validateTableAccess(sql, familyId);

        // 4. è‡ªåŠ¨æ·»åŠ æ•°æ®éš”ç¦»æ¡ä»¶
        return addDataIsolationCondition(sql, familyId);
    }

    private boolean containsSQLInjection(String sql) {
        // æ£€æµ‹å¸¸è§SQLæ³¨å…¥æ¨¡å¼
        String normalized = sql.toUpperCase().replaceAll("\\s+", " ");

        return normalized.contains("'; DROP") ||
               normalized.contains("' OR '1'='1") ||
               normalized.contains("' UNION SELECT") ||
               normalized.contains("/*") ||
               normalized.contains("--");
    }

    private ParsedSQL addDataIsolationCondition(String sql, String familyId) {
        // è‡ªåŠ¨åœ¨WHEREå­å¥ä¸­æ·»åŠ  family_id æ¡ä»¶
        if (sql.toUpperCase().contains("WHERE")) {
            sql = sql.replaceFirst("(?i)WHERE",
                "WHERE family_id = '" + familyId + "' AND");
        } else if (sql.toUpperCase().contains("FROM")) {
            sql = sql.replaceFirst("(?i)(FROM\\s+\\w+)",
                "$1 WHERE family_id = '" + familyId + "'");
        }

        return new ParsedSQL(sql, familyId);
    }
}
```

### æƒé™æ§åˆ¶å®ç°

```java
/**
 * æ•°æ®åº“æƒé™æ§åˆ¶æœåŠ¡
 */
@Service
public class DatabasePermissionService {

    // æœåŠ¡æƒé™æ˜ å°„
    private static final Map<String, Set<String>> SERVICE_PERMISSIONS = Map.of(
        "account-service", Set.of("users", "roles", "permissions"),
        "message-service", Set.of("messages", "conversations"),
        "device-service", Set.of("devices", "device_states", "device_logs"),
        "ai-service", Set.of("ai_models", "ai_sessions", "ai_results")
    );

    public void checkPermission(DatabaseProxyRequest request) {
        String serviceId = request.getServiceId();
        String targetTable = extractTableName(request.getSql());

        // æ£€æŸ¥æœåŠ¡æ˜¯å¦æœ‰è®¿é—®è¯¥è¡¨çš„æƒé™
        Set<String> allowedTables = SERVICE_PERMISSIONS.get(serviceId);
        if (allowedTables == null || !allowedTables.contains(targetTable)) {
            throw new SecurityException(
                String.format("æœåŠ¡ %s æ— æƒè®¿é—®è¡¨ %s", serviceId, targetTable));
        }

        // æ£€æŸ¥æ“ä½œæƒé™
        checkOperationPermission(request);

        // è®°å½•æƒé™å®¡è®¡æ—¥å¿—
        auditPermissionCheck(request, targetTable);
    }

    private void checkOperationPermission(DatabaseProxyRequest request) {
        String operation = request.getOperation().toUpperCase();
        String serviceId = request.getServiceId();

        // æŸäº›æœåŠ¡åªå…è®¸è¯»æ“ä½œ
        if ("ai-service".equals(serviceId) && !"SELECT".equals(operation)) {
            throw new SecurityException("AIæœåŠ¡åªå…è®¸æ‰§è¡ŒæŸ¥è¯¢æ“ä½œ");
        }

        // ç®¡ç†å‘˜æ“ä½œæƒé™æ£€æŸ¥
        if (isAdminOperation(operation) && !isAdminService(serviceId)) {
            throw new SecurityException("éç®¡ç†å‘˜æœåŠ¡ä¸å…è®¸æ‰§è¡Œç®¡ç†å‘˜æ“ä½œ");
        }
    }
}
```

## ğŸ”— è¿æ¥æ± ç®¡ç†

### æ™ºèƒ½è¿æ¥æ± æ¶æ„

```mermaid
graph TB
    subgraph "è¿æ¥æ± ç®¡ç†å™¨"
        A[ä¸»è¿æ¥æ± ]
        B[åªè¯»è¿æ¥æ± ]
        C[äº‹åŠ¡è¿æ¥æ± ]
        D[è¿æ¥å¥åº·æ£€æŸ¥]
        E[è¿æ¥è´Ÿè½½å‡è¡¡]
    end

    subgraph "PostgreSQLé›†ç¾¤"
        F[ä¸»åº“ - å†™å…¥]
        G[ä»åº“1 - åªè¯»]
        H[ä»åº“2 - åªè¯»]
    end

    subgraph "MongoDBé›†ç¾¤"
        I[PrimaryèŠ‚ç‚¹]
        J[SecondaryèŠ‚ç‚¹1]
        K[SecondaryèŠ‚ç‚¹2]
    end

    A --> F
    B --> G
    B --> H
    C --> F

    A --> I
    B --> J
    B --> K

    D --> A
    D --> B
    D --> C

    E --> A
    E --> B
```

### è¿æ¥æ± é…ç½®å®ç°

```java
/**
 * æ™ºèƒ½è¿æ¥æ± ç®¡ç†å™¨
 */
@Component
@ConfigurationProperties(prefix = "database.pool")
public class ConnectionPoolManager {

    private final Map<String, HikariDataSource> dataSources = new ConcurrentHashMap<>();
    private final Map<String, ConnectionPoolStats> poolStats = new ConcurrentHashMap<>();

    /**
     * è·å–æ•°æ®åº“è¿æ¥
     */
    public Connection getConnection(DatabaseProxyRequest request) {
        String poolKey = buildPoolKey(request);
        HikariDataSource dataSource = getOrCreateDataSource(poolKey, request);

        try {
            Connection connection = dataSource.getConnection();
            recordConnectionMetrics(poolKey);
            return connection;

        } catch (SQLException e) {
            // è¿æ¥è·å–å¤±è´¥ï¼Œå°è¯•æ•…éšœåˆ‡æ¢
            return tryFailover(request, e);
        }
    }

    private HikariDataSource createDataSource(String databaseType, String node) {
        HikariConfig config = new HikariConfig();

        // åŸºç¡€è¿æ¥é…ç½®
        config.setJdbcUrl(buildJdbcUrl(databaseType, node));
        config.setUsername(getUsername(databaseType));
        config.setPassword(getPassword(databaseType));

        // è¿æ¥æ± é…ç½®
        config.setMaximumPoolSize(20);          // æœ€å¤§è¿æ¥æ•°
        config.setMinimumIdle(5);               // æœ€å°ç©ºé—²è¿æ¥
        config.setConnectionTimeout(30000);     // è¿æ¥è¶…æ—¶30ç§’
        config.setIdleTimeout(600000);          // ç©ºé—²è¶…æ—¶10åˆ†é’Ÿ
        config.setMaxLifetime(1800000);         // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ30åˆ†é’Ÿ

        // å¥åº·æ£€æŸ¥é…ç½®
        config.setValidationTimeout(5000);      // éªŒè¯è¶…æ—¶5ç§’
        config.setLeakDetectionThreshold(60000); // è¿æ¥æ³„éœ²æ£€æµ‹1åˆ†é’Ÿ

        // æ€§èƒ½ä¼˜åŒ–é…ç½®
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");

        return new HikariDataSource(config);
    }

    /**
     * è¿æ¥æ± å¥åº·æ£€æŸ¥
     */
    @Scheduled(fixedRate = 30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void healthCheck() {
        dataSources.forEach((poolKey, dataSource) -> {
            try {
                // æµ‹è¯•è¿æ¥å¯ç”¨æ€§
                try (Connection conn = dataSource.getConnection()) {
                    boolean isValid = conn.isValid(5);
                    updatePoolHealth(poolKey, isValid);
                }

                // è®°å½•è¿æ¥æ± çŠ¶æ€
                recordPoolStats(poolKey, dataSource);

            } catch (SQLException e) {
                log.warn("è¿æ¥æ± å¥åº·æ£€æŸ¥å¤±è´¥: poolKey={}, error={}", poolKey, e.getMessage());
                markPoolUnhealthy(poolKey);
            }
        });
    }

    private void recordPoolStats(String poolKey, HikariDataSource dataSource) {
        HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();

        ConnectionPoolStats stats = ConnectionPoolStats.builder()
            .activeConnections(poolBean.getActiveConnections())
            .idleConnections(poolBean.getIdleConnections())
            .totalConnections(poolBean.getTotalConnections())
            .threadsAwaitingConnection(poolBean.getThreadsAwaitingConnection())
            .build();

        poolStats.put(poolKey, stats);

        // å‘é€ç›‘æ§æŒ‡æ ‡
        sendMetrics(poolKey, stats);
    }
}
```

## ğŸš€ TCPä»£ç†ä½¿ç”¨æŒ‡å—

### 1. å¾®æœåŠ¡é…ç½®

#### Javaå¾®æœåŠ¡è¿æ¥é…ç½®
```yaml
# application.yml - ä½¿ç”¨ä»£ç†çš„é…ç½®
spring:
  datasource:
    driver-class-name: org.postgresql.Driver
    # è¿æ¥åˆ°ä»£ç†ç«¯å£ï¼Œè€Œä¸æ˜¯çœŸå®æ•°æ®åº“ç«¯å£
    url: jdbc:postgresql://storage-service:5433/smarthome
    username: ${POSTGRESQL_USER:postgres}
    password: ${POSTGRESQL_PASSWORD:password}
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
```

#### å¯¹æ¯”ï¼šä¸ä½¿ç”¨ä»£ç†çš„é…ç½®
```yaml
# ç›´è¿æ•°æ®åº“çš„é…ç½®ï¼ˆä¸æ¨èï¼‰
spring:
  datasource:
    url: jdbc:postgresql://postgres:5432/smarthome  # ç›´è¿ç«¯å£5432
```

### 2. è¿æ¥å­—ç¬¦ä¸²å¯¹æ¯”

#### ä½¿ç”¨ä»£ç†ï¼ˆæ¨èï¼‰
```java
// å¾®æœåŠ¡é€šè¿‡ä»£ç†è¿æ¥
String proxyUrl = "jdbc:postgresql://storage-service:5433/smarthome";
```

#### ç›´è¿æ•°æ®åº“
```java
// ç›´æ¥è¿æ¥æ•°æ®åº“ï¼ˆç»•è¿‡ä»£ç†ï¼‰
String directUrl = "jdbc:postgresql://postgres:5432/smarthome";
```

### 3. ä»£ç†æœåŠ¡ç«¯å£é…ç½®

```yaml
# storage-service ä»£ç†ç«¯å£é…ç½®
proxy:
  enabled: true
  postgresql:
    port: 5433          # ä»£ç†ç›‘å¬ç«¯å£
    backend:
      host: postgres    # åç«¯çœŸå®æ•°æ®åº“ä¸»æœº
      port: 5432        # åç«¯çœŸå®æ•°æ®åº“ç«¯å£
    pool:
      max-connections: 50
      min-idle: 5
      connection-timeout: 30000

  mongodb:
    port: 27018         # MongoDBä»£ç†ç«¯å£
    backend:
      host: mongodb
      port: 27017

  redis:
    port: 6380          # Redisä»£ç†ç«¯å£
    backend:
      host: redis
      port: 6379
```

### 4. ä½¿ç”¨ä»£ç† vs ç›´è¿æ•°æ®åº“

#### ğŸ”„ ä½¿ç”¨ä»£ç†çš„ä¼˜åŠ¿
- âœ… **ç»Ÿä¸€ç®¡æ§**ï¼šé›†ä¸­çš„è¿æ¥æ± ç®¡ç†å’Œç›‘æ§
- âœ… **å®‰å…¨é˜²æŠ¤**ï¼šSQLæ³¨å…¥é˜²æŠ¤ã€å±é™©æ“ä½œæ‹¦æˆª
- âœ… **æ“ä½œå®¡è®¡**ï¼šå®Œæ•´çš„æ•°æ®åº“æ“ä½œæ—¥å¿—è®°å½•
- âœ… **æ€§èƒ½ä¼˜åŒ–**ï¼šè¿æ¥å¤ç”¨ã€è¯»å†™åˆ†ç¦»ã€è´Ÿè½½å‡è¡¡
- âœ… **æ•…éšœæ¢å¤**ï¼šè‡ªåŠ¨æ•…éšœæ£€æµ‹å’Œè¿æ¥é‡å»º

#### âš¡ ç›´è¿æ•°æ®åº“çš„åœºæ™¯
- **é«˜æ€§èƒ½è¦æ±‚**ï¼šå»¶è¿Ÿæ•æ„Ÿçš„æ ¸å¿ƒä¸šåŠ¡ï¼ˆå¦‚å®æ—¶äº¤æ˜“ï¼‰
- **ç‰¹æ®Šåè®®éœ€æ±‚**ï¼šéœ€è¦ä½¿ç”¨ä»£ç†ä¸æ”¯æŒçš„é«˜çº§PostgreSQLç‰¹æ€§
- **ä¸´æ—¶è°ƒè¯•**ï¼šå¼€å‘è°ƒè¯•é˜¶æ®µç›´è¿æ•°æ®åº“è¿›è¡Œé—®é¢˜æ’æŸ¥

#### ğŸ“‹ å¾®æœåŠ¡è¿æ¥æ–¹å¼é€‰æ‹©å»ºè®®

| å¾®æœåŠ¡ | æ¨èæ–¹å¼ | ç«¯å£ | åŸå›  |
|--------|----------|------|------|
| account-service | ğŸ”— ä½¿ç”¨ä»£ç† | :5433 | éœ€è¦æ“ä½œå®¡è®¡å’Œå®‰å…¨é˜²æŠ¤ |
| message-service | ğŸ”— ä½¿ç”¨ä»£ç† | :5433 | éœ€è¦æ•°æ®éš”ç¦»å’Œæ—¥å¿—è®°å½• |
| ai-service | âš¡ å¯ç›´è¿ | :5432 | é«˜é¢‘AIæ¨ç†ï¼Œæ€§èƒ½æ•æ„Ÿ |
| nlp-service | ğŸ”— ä½¿ç”¨ä»£ç† | :5433 | æ ‡å‡†CRUDæ“ä½œ |
| file-manager-service | ğŸ”— ä½¿ç”¨ä»£ç† | :5433 | éœ€è¦æ–‡ä»¶è®¿é—®æƒé™æ§åˆ¶ |

#### ğŸ”§ åŠ¨æ€åˆ‡æ¢ç¤ºä¾‹
```yaml
# å¼€å‘ç¯å¢ƒï¼šä½¿ç”¨ä»£ç†ä¾¿äºè°ƒè¯•
spring:
  profiles: development
  datasource:
    url: jdbc:postgresql://storage-service:5433/smarthome

---
# ç”Ÿäº§ç¯å¢ƒé«˜æ€§èƒ½æœåŠ¡ï¼šç›´è¿æ•°æ®åº“
spring:
  profiles: production-high-performance
  datasource:
    url: jdbc:postgresql://postgres:5432/smarthome
```

### 2. MongoDB ä»£ç†è®¿é—®

#### æŸ¥è¯¢è®¾å¤‡çŠ¶æ€
```bash
curl -X POST http://storage-service:8081/api/v1/proxy/mongodb \
  -H "Service-Key: key_device_xxx" \
  -H "X-Family-ID: family123" \
  -H "Content-Type: application/json" \
  -d '{
    "operation": "find",
    "targetDatabase": "smarthome",
    "sql": "db.device_states.find({\"deviceId\": \"device_001\", \"timestamp\": {\"$gte\": \"2024-01-15\"}})",
    "options": {
      "readOnly": true,
      "preferredNode": "secondary"
    }
  }'
```

#### æ›´æ–°è®¾å¤‡çŠ¶æ€
```bash
curl -X POST http://storage-service:8081/api/v1/proxy/mongodb \
  -H "Service-Key: key_device_xxx" \
  -H "X-Family-ID: family123" \
  -H "Content-Type: application/json" \
  -d '{
    "operation": "updateOne",
    "targetDatabase": "smarthome",
    "sql": "db.device_states.updateOne({\"deviceId\": \"device_001\"}, {\"$set\": {\"status\": \"online\", \"lastUpdate\": \"2024-01-15T10:30:00Z\"}})",
    "options": {
      "enableTransaction": false
    }
  }'
```

### 3. Redis ä»£ç†è®¿é—®

#### è®¾ç½®ç¼“å­˜æ•°æ®
```bash
curl -X POST http://storage-service:8081/api/v1/proxy/redis \
  -H "Service-Key: key_account_xxx" \
  -H "X-Family-ID: family123" \
  -H "Content-Type: application/json" \
  -d '{
    "operation": "set",
    "sql": "SET session:user123 \"{\\\"userId\\\": \\\"user123\\\", \\\"loginTime\\\": \\\"2024-01-15T10:30:00Z\\\"}\" EX 3600",
    "options": {
      "timeout": 5
    }
  }'
```

#### è·å–ç¼“å­˜æ•°æ®
```bash
curl -X POST http://storage-service:8081/api/v1/proxy/redis \
  -H "Service-Key: key_account_xxx" \
  -H "X-Family-ID: family123" \
  -H "Content-Type: application/json" \
  -d '{
    "operation": "get",
    "sql": "GET session:user123",
    "options": {
      "readOnly": true
    }
  }'
```

## ğŸ“ˆ ä»£ç†æ€§èƒ½ä¼˜åŒ–

### 1. æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥

```java
/**
 * æŸ¥è¯¢ä¼˜åŒ–å™¨
 */
@Component
public class QueryOptimizerService {

    /**
     * SQLæŸ¥è¯¢ä¼˜åŒ–
     */
    public OptimizedQuery optimize(ParsedSQL parsedSQL, DatabaseProxyRequest request) {
        OptimizedQuery.Builder builder = OptimizedQuery.builder()
            .originalSQL(parsedSQL.getSql())
            .familyId(request.getFamilyId());

        // 1. ç´¢å¼•å»ºè®®
        suggestIndexes(builder, parsedSQL);

        // 2. æŸ¥è¯¢é‡å†™
        rewriteQuery(builder, parsedSQL);

        // 3. åˆ†é¡µä¼˜åŒ–
        optimizePagination(builder, parsedSQL);

        // 4. ç¼“å­˜ç­–ç•¥
        determineCacheStrategy(builder, parsedSQL, request);

        return builder.build();
    }

    private void rewriteQuery(OptimizedQuery.Builder builder, ParsedSQL parsedSQL) {
        String sql = parsedSQL.getSql();

        // é¿å… SELECT *
        if (sql.contains("SELECT *")) {
            sql = replaceSelectAll(sql);
        }

        // æ·»åŠ  LIMIT é˜²æ­¢å¤§ç»“æœé›†
        if (!sql.toUpperCase().contains("LIMIT") &&
            sql.toUpperCase().startsWith("SELECT")) {
            sql += " LIMIT 1000";
        }

        // ä¼˜åŒ– ORDER BY
        sql = optimizeOrderBy(sql);

        builder.optimizedSQL(sql);
    }

    private void determineCacheStrategy(OptimizedQuery.Builder builder,
                                      ParsedSQL parsedSQL,
                                      DatabaseProxyRequest request) {
        String sql = parsedSQL.getSql().toUpperCase();

        // åªè¯»æŸ¥è¯¢ä¸”ç»“æœå¯é¢„æœŸçš„æ‰ç¼“å­˜
        if (sql.startsWith("SELECT") &&
            !sql.contains("NOW()") &&
            !sql.contains("RANDOM()") &&
            request.getOptions().isUseCache()) {

            String cacheKey = generateCacheKey(parsedSQL, request.getFamilyId());
            int ttl = determineCacheTTL(sql);

            builder.cacheKey(cacheKey).cacheTTL(ttl);
        }
    }
}
```

### 2. è¿æ¥è´Ÿè½½å‡è¡¡

```java
/**
 * è¿æ¥è´Ÿè½½å‡è¡¡å™¨
 */
@Component
public class ConnectionLoadBalancer {

    private final List<DatabaseNode> readNodes = new ArrayList<>();
    private final AtomicInteger currentIndex = new AtomicInteger(0);

    public DatabaseNode selectReadNode(DatabaseProxyRequest request) {
        // è¿‡æ»¤å¥åº·çš„åªè¯»èŠ‚ç‚¹
        List<DatabaseNode> healthyNodes = readNodes.stream()
            .filter(DatabaseNode::isHealthy)
            .collect(Collectors.toList());

        if (healthyNodes.isEmpty()) {
            throw new RuntimeException("æ²¡æœ‰å¯ç”¨çš„åªè¯»èŠ‚ç‚¹");
        }

        // è´Ÿè½½å‡è¡¡ç­–ç•¥é€‰æ‹©
        return switch (getLoadBalanceStrategy()) {
            case ROUND_ROBIN -> roundRobinSelect(healthyNodes);
            case LEAST_CONNECTIONS -> leastConnectionsSelect(healthyNodes);
            case WEIGHTED_ROUND_ROBIN -> weightedRoundRobinSelect(healthyNodes);
            case RANDOM -> randomSelect(healthyNodes);
            default -> roundRobinSelect(healthyNodes);
        };
    }

    private DatabaseNode roundRobinSelect(List<DatabaseNode> nodes) {
        int index = currentIndex.getAndIncrement() % nodes.size();
        return nodes.get(index);
    }

    private DatabaseNode leastConnectionsSelect(List<DatabaseNode> nodes) {
        return nodes.stream()
            .min(Comparator.comparing(DatabaseNode::getActiveConnections))
            .orElse(nodes.get(0));
    }

    private DatabaseNode weightedRoundRobinSelect(List<DatabaseNode> nodes) {
        int totalWeight = nodes.stream()
            .mapToInt(DatabaseNode::getWeight)
            .sum();

        int randomWeight = ThreadLocalRandom.current().nextInt(totalWeight);
        int currentWeight = 0;

        for (DatabaseNode node : nodes) {
            currentWeight += node.getWeight();
            if (randomWeight < currentWeight) {
                return node;
            }
        }

        return nodes.get(0);
    }
}
```

## ğŸ” ä»£ç†ç›‘æ§å’Œå‘Šè­¦

### å…³é”®æ€§èƒ½æŒ‡æ ‡

```java
/**
 * æ•°æ®åº“ä»£ç†ç›‘æ§æŒ‡æ ‡
 */
@Component
public class DatabaseProxyMetrics {

    private final MeterRegistry registry;

    // è¯·æ±‚è®¡æ•°å’Œè€—æ—¶
    @Timed("proxy.request.time")
    @Counted("proxy.request.count")
    public DatabaseProxyResponse processProxyRequest(DatabaseProxyRequest request) {
        return doProcessRequest(request);
    }

    // è¿æ¥æ± ç›‘æ§
    @Scheduled(fixedRate = 30000)
    public void collectConnectionPoolMetrics() {
        connectionPools.forEach((name, pool) -> {
            registry.gauge("proxy.pool.active", Tags.of("pool", name),
                          pool.getActiveConnections());
            registry.gauge("proxy.pool.idle", Tags.of("pool", name),
                          pool.getIdleConnections());
            registry.gauge("proxy.pool.total", Tags.of("pool", name),
                          pool.getTotalConnections());
        });
    }

    // æŸ¥è¯¢æ€§èƒ½ç›‘æ§
    @EventListener
    public void onQueryExecuted(QueryExecutedEvent event) {
        registry.timer("proxy.query.execution.time",
                      Tags.of("database", event.getDatabaseType(),
                             "operation", event.getOperation()))
                .record(event.getExecutionTime(), TimeUnit.MILLISECONDS);

        // æ…¢æŸ¥è¯¢å‘Šè­¦
        if (event.getExecutionTime() > 2000) {
            alertSlowQuery(event);
        }
    }

    // æ•…éšœåˆ‡æ¢ç›‘æ§
    @EventListener
    public void onFailover(FailoverEvent event) {
        registry.counter("proxy.failover.count",
                        Tags.of("from", event.getFromNode(),
                               "to", event.getToNode()))
                .increment();

        log.warn("æ•°æ®åº“æ•…éšœåˆ‡æ¢: {} -> {}, åŸå› : {}",
                event.getFromNode(), event.getToNode(), event.getReason());
    }
}
```

### å‘Šè­¦è§„åˆ™é…ç½®

```yaml
# ä»£ç†ç›‘æ§å‘Šè­¦è§„åˆ™
proxy:
  alerts:
    # å“åº”æ—¶é—´å‘Šè­¦
    response_time:
      threshold: 2000ms      # è¶…è¿‡2ç§’å‘Šè­¦
      duration: 1m           # æŒç»­1åˆ†é’Ÿ
      severity: warning

    # è¿æ¥æ± å‘Šè­¦
    connection_pool:
      active_threshold: 90%   # æ´»è·ƒè¿æ¥è¶…è¿‡90%
      wait_threshold: 10      # ç­‰å¾…è¿æ¥æ•°è¶…è¿‡10
      severity: critical

    # é”™è¯¯ç‡å‘Šè­¦
    error_rate:
      threshold: 5%          # é”™è¯¯ç‡è¶…è¿‡5%
      duration: 5m           # æŒç»­5åˆ†é’Ÿ
      severity: critical

    # æ•…éšœåˆ‡æ¢å‘Šè­¦
    failover:
      frequency: 3           # 5åˆ†é’Ÿå†…æ•…éšœåˆ‡æ¢è¶…è¿‡3æ¬¡
      duration: 5m
      severity: critical
```

## ğŸ› ï¸ ä»£ç†æ•…éšœæ’æŸ¥

### å¸¸è§ä»£ç†é—®é¢˜

#### 1. è¿æ¥è¶…æ—¶é—®é¢˜
```bash
# æ£€æŸ¥è¿æ¥æ± çŠ¶æ€
curl http://storage-service:8081/actuator/metrics/proxy.pool.active

# æ£€æŸ¥æ•°æ®åº“è¿æ¥å¥åº·çŠ¶æ€
curl http://storage-service:8081/api/v1/proxy/health/connections

# æŸ¥çœ‹è¿æ¥ç­‰å¾…æƒ…å†µ
curl http://storage-service:8081/actuator/metrics/proxy.pool.pending
```

#### 2. æŸ¥è¯¢æ€§èƒ½é—®é¢˜
```bash
# æŸ¥çœ‹æ…¢æŸ¥è¯¢ç»Ÿè®¡
curl http://storage-service:8081/api/v1/proxy/metrics/slow-queries

# æ£€æŸ¥ç¼“å­˜å‘½ä¸­ç‡
curl http://storage-service:8081/actuator/metrics/proxy.cache.hit.ratio

# åˆ†ææŸ¥è¯¢æ‰§è¡Œè®¡åˆ’
curl -X POST http://storage-service:8081/api/v1/proxy/debug/explain \
  -d '{"sql": "SELECT * FROM users WHERE family_id = ?"}'
```

#### 3. æƒé™è®¿é—®é—®é¢˜
```bash
# æ£€æŸ¥æœåŠ¡æƒé™é…ç½®
curl http://storage-service:8081/api/v1/proxy/debug/permissions/{serviceId}

# éªŒè¯ familyId æ•°æ®éš”ç¦»
curl -H "X-Family-ID: family123" \
     http://storage-service:8081/api/v1/proxy/debug/isolation-check
```

### ä»£ç†æ•…éšœè‡ªåŠ¨æ¢å¤

```java
/**
 * ä»£ç†æ•…éšœè‡ªåŠ¨æ¢å¤æœºåˆ¶
 */
@Component
public class ProxyFailureRecovery {

    @EventListener
    public void onDatabaseConnectionFailure(ConnectionFailureEvent event) {
        String failedNode = event.getNodeId();

        // 1. æ ‡è®°èŠ‚ç‚¹ä¸ºä¸å¥åº·
        markNodeUnhealthy(failedNode);

        // 2. è§¦å‘æ•…éšœåˆ‡æ¢
        triggerFailover(failedNode);

        // 3. å¯åŠ¨è‡ªåŠ¨æ¢å¤æ£€æŸ¥
        scheduleRecoveryCheck(failedNode);
    }

    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    public void checkNodeRecovery() {
        List<DatabaseNode> unhealthyNodes = getUnhealthyNodes();

        for (DatabaseNode node : unhealthyNodes) {
            if (testNodeConnection(node)) {
                // èŠ‚ç‚¹æ¢å¤ï¼Œé‡æ–°åŠ å…¥è´Ÿè½½å‡è¡¡
                markNodeHealthy(node.getId());
                log.info("æ•°æ®åº“èŠ‚ç‚¹å·²æ¢å¤: {}", node.getId());
            }
        }
    }

    private void triggerFailover(String failedNode) {
        // å°†è¯¥èŠ‚ç‚¹çš„è¿æ¥è½¬ç§»åˆ°å…¶ä»–å¥åº·èŠ‚ç‚¹
        List<Connection> activeConnections = getActiveConnections(failedNode);

        for (Connection conn : activeConnections) {
            try {
                // ä¼˜é›…å…³é—­è¿æ¥
                conn.close();
            } catch (SQLException e) {
                log.warn("å…³é—­å¤±æ•ˆè¿æ¥å¤±è´¥: {}", e.getMessage());
            }
        }

        // é€šçŸ¥è¿æ¥æ± ç®¡ç†å™¨æ›´æ–°è·¯ç”±è§„åˆ™
        connectionPoolManager.updateRoutingRules(failedNode, false);
    }
}
```

## ğŸ“‹ ä»£ç†æœ€ä½³å®è·µ

### 1. æ€§èƒ½ä¼˜åŒ–å»ºè®®
- **è¿æ¥æ± é…ç½®**: æ ¹æ®ä¸šåŠ¡è´Ÿè½½åˆç†é…ç½®è¿æ¥æ± å¤§å°
- **è¯»å†™åˆ†ç¦»**: æŸ¥è¯¢æ“ä½œä¼˜å…ˆè·¯ç”±åˆ°åªè¯»èŠ‚ç‚¹
- **æŸ¥è¯¢ç¼“å­˜**: å¯¹é¢‘ç¹æŸ¥è¯¢çš„ç»“æœè¿›è¡Œç¼“å­˜
- **æ‰¹é‡æ“ä½œ**: ä½¿ç”¨æ‰¹é‡æ“ä½œå‡å°‘ç½‘ç»œå¾€è¿”

### 2. å®‰å…¨é˜²æŠ¤å»ºè®®
- **SQLæ³¨å…¥é˜²æŠ¤**: ä¸¥æ ¼éªŒè¯æ‰€æœ‰SQLè¯­å¥
- **æƒé™æœ€å°åŒ–**: æ¯ä¸ªæœåŠ¡åªæˆäºˆå¿…éœ€çš„æ•°æ®åº“æƒé™
- **æ•°æ®éš”ç¦»**: å¼ºåˆ¶æ‰§è¡ŒåŸºäºfamilyIdçš„æ•°æ®éš”ç¦»
- **å®¡è®¡æ—¥å¿—**: è®°å½•æ‰€æœ‰æ•°æ®åº“è®¿é—®æ“ä½œ

### 3. é«˜å¯ç”¨å»ºè®®
- **å¤šèŠ‚ç‚¹éƒ¨ç½²**: é…ç½®ä¸»ä»å¤åˆ¶å’Œæ•…éšœåˆ‡æ¢
- **å¥åº·æ£€æŸ¥**: å®šæœŸæ£€æŸ¥æ•°æ®åº“èŠ‚ç‚¹å¥åº·çŠ¶æ€
- **è‡ªåŠ¨æ¢å¤**: å®ç°æ•…éšœèŠ‚ç‚¹çš„è‡ªåŠ¨æ£€æµ‹å’Œæ¢å¤
- **è´Ÿè½½å‡è¡¡**: ä½¿ç”¨æ™ºèƒ½è´Ÿè½½å‡è¡¡åˆ†å‘è¯·æ±‚

### 4. å¼€å‘å»ºè®®
- **ç»Ÿä¸€æ¥å£**: ä½¿ç”¨æ ‡å‡†åŒ–çš„ä»£ç†APIæ¥å£
- **é”™è¯¯å¤„ç†**: å®ç°å®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- **ç›‘æ§å‘Šè­¦**: å»ºç«‹å®Œæ•´çš„ç›‘æ§å’Œå‘Šè­¦ä½“ç³»
- **æ–‡æ¡£ç»´æŠ¤**: ä¿æŒä»£ç†é…ç½®å’Œä½¿ç”¨æ–‡æ¡£çš„æ›´æ–°

---

**æ•°æ®åº“è®¿é—®ä»£ç†ç³»ç»Ÿ** - ä¸ºHavenButlerå¹³å°æä¾›å®‰å…¨ã€é«˜æ•ˆçš„æ•°æ®åº“ä»£ç†æœåŠ¡ ğŸ”—